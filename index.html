<!DOCTYPE html>
<html lang="en">

<head>
    <title>AR Tetris 3D (v55 - UI/UX Overhaul)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="xr-spatial-tracking" content="true">
    
    <!-- Load Google Font: Montserrat (Medium & Bold) -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;800&display=swap" rel="stylesheet">
    <!-- Load Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">

    <style>
        /* Basic reset */
        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Montserrat', sans-serif; 
            font-weight: 400; 
            background-color: #111;
            color: white;
            touch-action: none; 
        }

        /* The 3D canvas */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #default-ar-button {
            display: none !important;
            visibility: hidden !important;
        }

        /* --- Shared Glassmorphism Style --- */
        .glass-panel {
            background: rgba(20, 20, 20, 0.8); /* Darker, higher opacity */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            color: white;
            pointer-events: none; /* Default to no interaction */
        }

        /* --- 1. Unified HUD (Top Left) --- */
        #hud-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 100;
            min-width: 100px;
            opacity: 0; /* Hidden initially */
            transition: opacity 0.3s ease;
        }
        
        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .hud-label {
            color: #aaa;
            font-weight: 400;
            margin-right: 10px;
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        .hud-value {
            color: #FFDC00; /* Gold */
            font-family: 'Montserrat', monospace; /* Monospace numbers */
        }
        
        #level-value {
            color: #00FFFF; /* Cyan */
        }

        /* --- 2. Feedback & Affordance (Recording) --- */
        #recording-panel {
            position: absolute;
            top: 100px; /* Below HUD */
            left: 20px;
            display: none; /* Hidden until needed */
            flex-direction: row;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 20px;
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            z-index: 100;
        }
        
        #recording-dot {
            width: 8px;
            height: 8px;
            background-color: #FF4136;
            border-radius: 50%;
            animation: blink-red 1s infinite;
        }
        
        #recording-timer {
            font-size: 0.8rem;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: #FF4136;
        }

        @keyframes blink-red {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        /* --- 3. Consistent Iconography (Top Right Controls) --- */
        .control-btn {
            position: absolute;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 102;
            pointer-events: auto;
            transition: transform 0.1s, background-color 0.2s;
            /* Glass style */
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }
        
        .control-btn .material-icons-round {
            font-size: 24px;
        }

        #music-toggle {
            top: 20px;
            right: 20px;
        }

        #record-button {
            top: 74px; /* Below music toggle */
            right: 20px;
        }
        
        #record-button.recording {
            background: rgba(255, 65, 54, 0.2); /* Red tint */
            border-color: #FF4136;
        }
        
        #record-button.recording .material-icons-round {
            color: #FF4136;
        }

        /* --- 5. Onboarding & Instruction (Message Box) --- */
        #message-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            padding: 12px 24px;
            text-align: center;
            display: none; /* Flex when shown */
            align-items: center;
            gap: 10px;
            font-weight: 600;
            pointer-events: none;
            white-space: nowrap;
        }
        
        /* Phone sway animation */
        @keyframes sway {
            0% { transform: rotate(-10deg); }
            100% { transform: rotate(10deg); }
        }
        
        .phone-icon {
            font-size: 20px;
            animation: sway 1s ease-in-out infinite alternate;
            display: none; /* Only show during scanning */
        }

        /* Launch Button Pulse */
        @keyframes btn-pulse {
            0% { box-shadow: 0 0 0 0 rgba(138, 43, 226, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(138, 43, 226, 0); }
            100% { box-shadow: 0 0 0 0 rgba(138, 43, 226, 0); }
        }

        #custom-ar-button {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            padding: 16px 32px;
            border-radius: 50px;
            background: linear-gradient(135deg, #8a2be2, #4169e1);
            color: white;
            font-family: 'Montserrat', sans-serif;
            font-size: 1.1rem; 
            font-weight: 700;
            border: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            z-index: 101;
            transition: transform 0.2s;
            pointer-events: auto; 
            text-transform: uppercase;
            letter-spacing: 1px;
            animation: btn-pulse 2s infinite;
        }

        #custom-ar-button:active {
            transform: translateX(-50%) scale(0.95);
        }

        /* --- 6. Game Over Modal --- */
        #game-over-card {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 300px;
            padding: 30px 20px;
            display: none; /* Flex when shown */
            flex-direction: column;
            align-items: center;
            gap: 20px;
            z-index: 105;
            text-align: center;
            pointer-events: auto;
        }
        
        .go-title {
            font-size: 2rem;
            font-weight: 800;
            color: #FF4136;
            text-transform: uppercase;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .go-stats {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100%;
        }
        
        .go-stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 5px;
        }
        
        .go-label { color: #aaa; }
        .go-val { font-weight: 700; }

        #replay-button {
            padding: 12px 30px;
            border-radius: 25px;
            background: linear-gradient(135deg, #2ecc71, #27ae60); 
            color: white;
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem; 
            font-weight: 700;
            border: none;
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
            cursor: pointer;
            transition: transform 0.1s;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 100%;
        }

        #replay-button:active {
            transform: scale(0.95);
        }
        
        /* Intro Screen Styles */
        #intro-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.85); 
            backdrop-filter: blur(5px);
            z-index: 200; 
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        
        #intro-title {
            font-family: 'Montserrat', sans-serif; 
            font-weight: 900; 
            font-size: 3rem; 
            color: #FF00FF; 
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
            margin-bottom: 5px;
            text-align: center;
            letter-spacing: -1px;
            line-height: 1;
        }
        
        #intro-subtitle {
            font-family: 'Montserrat', sans-serif; 
            font-weight: 300;
            font-size: 1.2rem; 
            color: #00FFFF; 
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            letter-spacing: 6px;
            text-transform: uppercase;
        }

    </style>
</head>

<body>
    <!-- 1. Unified HUD -->
    <div id="hud-panel" class="glass-panel">
        <div class="hud-row">
            <span class="hud-label">Score</span>
            <span class="hud-value" id="score-val">0</span>
        </div>
        <div class="hud-row">
            <span class="hud-label">Level</span>
            <span class="hud-value" id="level-val">1</span>
        </div>
    </div>

    <!-- 2. Feedback (Recording) -->
    <div id="recording-panel">
        <div id="recording-dot"></div>
        <div id="recording-timer" id="rec-time">00:00</div>
    </div>

    <!-- 5. Onboarding Message -->
    <div id="message-box" class="glass-panel">
        <span class="material-icons-round phone-icon">smartphone</span>
        <span id="message-text">Scan floor to start</span>
    </div>

    <!-- 6. Game Over Modal -->
    <div id="game-over-card" class="glass-panel">
        <h1 class="go-title">Game Over</h1>
        <div class="go-stats">
            <div class="go-stat-row">
                <span class="go-label">Score</span>
                <span class="go-val" id="go-score">0</span>
            </div>
            <div class="go-stat-row">
                <span class="go-label">Level</span>
                <span class="go-val" id="go-level">1</span>
            </div>
        </div>
        <button id="replay-button">
            <span class="material-icons-round" style="vertical-align: middle; margin-right: 5px; font-size: 1.2rem;">replay</span>
            Play Again
        </button>
    </div>

    <!-- Intro Screen -->
    <div id="intro-screen">
        <div id="intro-title">ROCKIN'<br>TETRIS</div>
        <div id="intro-subtitle">in AR</div>
    </div>

    <!-- 3. Consistent Icons -->
    <!-- Music Toggle -->
    <button id="music-toggle" class="control-btn" aria-label="Toggle Music">
        <span class="material-icons-round" id="icon-music">volume_up</span>
    </button>

    <!-- Recording Button -->
    <button id="record-button" class="control-btn" aria-label="Record Video">
        <span class="material-icons-round" id="icon-record-btn">fiber_manual_record</span>
    </button>

    <button id="custom-ar-button">
        Launch AR
    </button>
    
    <!-- Audio -->
    <audio id="audio-tts" preload="auto" playsinline></audio>
    
    <audio id="audio-bgm" src="music/music.mp3" loop preload="auto" playsinline></audio>
    <audio id="audio-move" src="music/tik.mp3" preload="auto" playsinline></audio>
    <audio id="audio-gameover" src="music/outro.mp3" preload="auto" playsinline></audio>
    <audio id="audio-lineclear" src="music/lineclear.mp3" preload="auto" playsinline></audio>
    <audio id="audio-toot" src="data:audio/wav;base64,UklGRl9vT1ZYXxcqU1qa..." preload="auto" playsinline></audio>

    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        
        // --- Global Variables ---
        let camera, scene, renderer;
        let hitTestSource = null;
        let placementGrid = null; 
        let gameBoard = null; 
        let currentPiece = null;
        let gameLoopInterval = null;
        
        // UI Vars
        let customArButton, messageBox, messageText, phoneIcon;
        let hudPanel, scoreVal, levelVal;
        let gameOverCard, goScore, goLevel, replayButton;
        let musicToggleBtn, musicIcon, recordButton, recordIcon;
        let recordingPanel, recTimer;
        
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let recStartTime;
        let recInterval;
        
        let introScreen;
        
        const GAME_STATE = {
            INITIALIZING: 0,
            SCANNING: 1,
            PLACING: 2,
            PLAYING: 3,
            GAME_OVER: 4
        };
        let gameState = GAME_STATE.INITIALIZING;
        let score = 0;
        
        // --- Level Variables ---
        let level = 1;
        let linesClearedTotal = 0;
        let currentDropSpeed = 1000; 
        const MIN_DROP_SPEED = 100; 

        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20; 
        const BLOCK_SIZE = 0.1; 
        
        let grid = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
        
        const SHAPES = [
            [[[1,1,1,1]], [[1],[1],[1],[1]]],
            [[[1,1],[1,1]]],
            [[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]],
            [[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]],
            [[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]],
            [[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]],
            [[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]]
        ];
        const COLORS = {
            1: 0x00F0F0, 2: 0xF0F000, 3: 0xA000F0, 4: 0x00F000, 5: 0xF00000, 6: 0x0000F0, 7: 0xF0A000,
        };

        let moveSound, rotateSound, gameOverSound, bgmLoop, lineClearSound;
        let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let audioUnlocked = false;
        let isMusicMuted = false; 
        let blueGridMat, greenGridMat;

        function triggerHaptic(duration = 20) {
            if (navigator.vibrate) navigator.vibrate(duration);
        }

        function playToot() {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, audioCtx.currentTime); 
            osc.frequency.exponentialRampToValueAtTime(440, audioCtx.currentTime + 0.1); 
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); 
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }
        
        init();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(0, 10, 0);
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Bind UI Elements
            customArButton = document.getElementById('custom-ar-button');
            
            messageBox = document.getElementById('message-box');
            messageText = document.getElementById('message-text');
            phoneIcon = document.querySelector('.phone-icon');
            
            hudPanel = document.getElementById('hud-panel');
            scoreVal = document.getElementById('score-val');
            levelVal = document.getElementById('level-val');
            
            gameOverCard = document.getElementById('game-over-card');
            goScore = document.getElementById('go-score');
            goLevel = document.getElementById('go-level');
            replayButton = document.getElementById('replay-button');
            
            introScreen = document.getElementById('intro-screen');
            
            musicToggleBtn = document.getElementById('music-toggle');
            musicIcon = document.getElementById('icon-music');
            
            recordButton = document.getElementById('record-button');
            iconRecord = document.getElementById('icon-record-btn');
            recordingPanel = document.getElementById('recording-panel');
            recTimer = document.getElementById('recording-timer');

            bgmLoop = document.getElementById('audio-bgm');
            moveSound = document.getElementById('audio-move');
            rotateSound = document.getElementById('audio-move'); 
            gameOverSound = document.getElementById('audio-gameover');
            lineClearSound = document.getElementById('audio-lineclear');

            const arButton = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test'], 
                optionalFeatures: ['dom-overlay', 'local-floor'], 
                domOverlay: { root: document.body }
            });
            arButton.id = "default-ar-button"; 
            document.body.appendChild(arButton);

            // --- STRICT AUDIO UNLOCK ON CLICK ---
            customArButton.addEventListener('click', () => {
                console.log("Unlocking audio context...");
                if(audioCtx.state === 'suspended') audioCtx.resume();
                triggerHaptic(5); 
                const allSounds = [bgmLoop, moveSound, gameOverSound, lineClearSound];
                
                allSounds.forEach(s => {
                    if(s) {
                        const p = s.play();
                        if (p !== undefined) {
                            p.then(() => {
                                if(s === bgmLoop) {
                                    console.log("BGM started successfully");
                                } else {
                                    s.pause();
                                    s.currentTime = 0;
                                }
                            }).catch(e => console.warn("Audio play error:", e));
                        }
                    }
                });
                
                audioUnlocked = true;
                arButton.click(); 
            });
            
            replayButton.addEventListener('click', () => {
                triggerHaptic(5); 
                resetGame();
            });

            musicToggleBtn.addEventListener('click', () => {
                triggerHaptic(5); 
                toggleMusic();
            });

            recordButton.addEventListener('click', () => {
                triggerHaptic(20);
                playToot(); 
                if (!isRecording) {
                    startRecording();
                } else {
                    stopRecording();
                }
            });

            renderer.xr.addEventListener('sessionstart', () => {
                if (gameState === GAME_STATE.INITIALIZING) {
                    // Volume Settings
                    if (bgmLoop) bgmLoop.volume = 0.05; 
                    if (moveSound) moveSound.volume = 0.15; 
                    if (rotateSound) rotateSound.volume = 0.15; 
                    if (gameOverSound) gameOverSound.volume = 0.1; 
                    if (lineClearSound) lineClearSound.volume = 0.1; 

                    if (bgmLoop && bgmLoop.paused && !isMusicMuted) {
                        bgmLoop.play().catch(e => console.error("BGM resume error:", e));
                    }
                    
                    customArButton.style.display = 'none';
                    // Show Controls
                    recordButton.style.display = 'flex';
                    
                    gameState = GAME_STATE.SCANNING;
                    updateMessage("Scan floor to start", true); // Show icon

                    const currentSession = renderer.xr.getSession();
                    currentSession.requestReferenceSpace('viewer').then((referenceSpace) => {
                        currentSession.requestHitTestSource({ 
                            space: referenceSpace 
                        }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                }
            });
            
            renderer.xr.addEventListener('sessionend', () => {
                if (bgmLoop) bgmLoop.pause();
                if (isRecording) stopRecording();
                recordButton.style.display = 'none';
                window.location.reload();
            });

            // Touch Controls
            let touchStartX, touchStartY, touchStartTime;
            let strafeInterval = null;
            let isDragging = false;
            const DRAG_THRESHOLD_Y = 75; 
            const STRAFE_INTERVAL_MS = 130; 

            function onTouchStart(e) {
                if (e.target.tagName === 'BUTTON' || e.target.closest('#music-toggle') || e.target.closest('#record-button') || e.target.closest('#replay-button')) return;

                e.preventDefault(); 
                if (gameState === GAME_STATE.PLACING) {
                    updateMessage("", false); 
                    playIntroAndStart(); 
                    return; 
                }
                if (gameState !== GAME_STATE.PLAYING || e.touches.length > 1) return; 

                if (strafeInterval) clearInterval(strafeInterval);
                const touch = e.touches[0];
                touchStartX = touch.pageX;
                touchStartY = touch.pageY;
                touchStartTime = new Date().getTime();
                isDragging = false;

                const screenWidth = window.innerWidth;
                if (touchStartX < screenWidth * 0.33) {
                    movePiece(-1); 
                    strafeInterval = setInterval(() => movePiece(-1), STRAFE_INTERVAL_MS);
                } else if (touchStartX > screenWidth * 0.66) {
                    movePiece(1); 
                    strafeInterval = setInterval(() => movePiece(1), STRAFE_INTERVAL_MS);
                }
            }
            
            function onTouchMove(e) {
                if (e.target.tagName === 'BUTTON' || e.target.closest('#music-toggle') || e.target.closest('#record-button')) return;
                e.preventDefault();
                if (gameState !== GAME_STATE.PLAYING || !touchStartY || e.touches.length > 1) return;
                
                const touch = e.touches[0];
                const deltaY = touch.pageY - touchStartY;
                
                if (deltaY > DRAG_THRESHOLD_Y) {
                    if (strafeInterval) clearInterval(strafeInterval); 
                    hardDrop();
                    touchStartY = null; 
                    touchStartX = null;
                    isDragging = true; 
                }
            }
            
            function onTouchEnd(e) {
                if (e.target.tagName === 'BUTTON' || e.target.closest('#music-toggle') || e.target.closest('#record-button')) return;
                e.preventDefault();
                if (gameState !== GAME_STATE.PLAYING) return;
                if (strafeInterval) clearInterval(strafeInterval);
                if (isDragging) { isDragging = false; return; }
                
                const screenWidth = window.innerWidth;
                const touchTime = new Date().getTime() - touchStartTime;

                if (touchTime < STRAFE_INTERVAL_MS * 1.5) { 
                    if (touchStartX > screenWidth * 0.33 && touchStartX < screenWidth * 0.66) {
                        rotatePiece();
                    }
                }
            }
            
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
            renderer.domElement.addEventListener('touchcancel', onTouchEnd, { passive: false });

            window.addEventListener('resize', onWindowResize);
            
            // Materials
            blueGridMat = new THREE.MeshBasicMaterial({ color: 0x00FFFF, wireframe: true, transparent: true, opacity: 0.7 });
            greenGridMat = new THREE.MeshBasicMaterial({ color: 0x00FF00, wireframe: true, transparent: true, opacity: 0.8 });

            const gridGeo = new THREE.PlaneGeometry(BOARD_WIDTH * BLOCK_SIZE, BOARD_WIDTH * BLOCK_SIZE, BOARD_WIDTH, BOARD_WIDTH);
            placementGrid = new THREE.Mesh(gridGeo, blueGridMat);
            placementGrid.visible = false;
            gridGeo.rotateX(-Math.PI / 2);

            scene.add(placementGrid);
            
            gameBoard = new THREE.Group();
            renderer.setAnimationLoop(animate);
        }

        function startRecording() {
            const stream = renderer.domElement.captureStream(30); 
            const mimeType = MediaRecorder.isTypeSupported('video/mp4') ? 'video/mp4' : 'video/webm';
            
            try {
                mediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });
            } catch (e) {
                console.error("MediaRecorder setup failed:", e);
                // updateMessage("Recording not supported"); // Dont show msg in HUD
                return;
            }

            recordedChunks = [];
            mediaRecorder.ondataavailable = (event) => { if (event.data.size > 0) recordedChunks.push(event.data); };
            mediaRecorder.onstop = saveAndShareVideo;
            mediaRecorder.start();
            isRecording = true;
            
            recordButton.classList.add('recording');
            iconRecord.textContent = "stop"; // Change icon using text (material icons)
            recordingPanel.style.display = 'flex';
            
            // Start timer
            recStartTime = Date.now();
            recInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - recStartTime) / 1000);
                const m = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const s = (elapsed % 60).toString().padStart(2, '0');
                recTimer.textContent = `${m}:${s}`;
            }, 1000);
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                clearInterval(recInterval);
                
                recordButton.classList.remove('recording');
                iconRecord.textContent = "fiber_manual_record";
                recordingPanel.style.display = 'none';
                recTimer.textContent = "00:00";
            }
        }

        function saveAndShareVideo() {
            const blob = new Blob(recordedChunks, { type: 'video/mp4' }); 
            const file = new File([blob], "ar-tetris-gameplay.mp4", { type: 'video/mp4' });

            if (navigator.canShare && navigator.canShare({ files: [file] })) {
                navigator.share({
                    title: 'My AR Tetris Gameplay!',
                    text: 'Check out this cool AR Tetris game!',
                    files: [file]
                }).catch((error) => { downloadVideo(blob); });
            } else {
                downloadVideo(blob);
            }
        }

        function downloadVideo(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            document.body.appendChild(a);
            a.style = 'display: none';
            a.href = url;
            a.download = 'ar-tetris-gameplay.mp4';
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function toggleMusic() {
            if (!bgmLoop) return;

            if (isMusicMuted) {
                bgmLoop.play().catch(e => console.error("BGM play failed:", e));
                musicIcon.textContent = "volume_up";
                isMusicMuted = false;
            } else {
                bgmLoop.pause();
                musicIcon.textContent = "volume_off";
                isMusicMuted = true;
            }
        }

        function playSound(audioElement) {
            if (!audioElement) return;
            audioElement.currentTime = 0; 
            audioElement.play().catch(e => console.warn("Sound play warning:", e)); 
        }

        function animate(timestamp, frame) {
            if (frame) {
                const session = renderer.xr.getSession();
                if (!session) {
                    renderer.render(scene, camera);
                    return;
                }

                if (gameState === GAME_STATE.SCANNING || gameState === GAME_STATE.PLACING) {
                    if (hitTestSource) {
                        const hitTestResults = frame.getHitTestResults(hitTestSource); 

                        if (hitTestResults.length > 0) {
                            const hit = hitTestResults[0];
                            const referenceSpace = renderer.xr.getReferenceSpace();
                            const pose = hit.getPose(referenceSpace);
                            
                            placementGrid.matrix.fromArray(pose.transform.matrix);
                            placementGrid.matrixAutoUpdate = false; 
                            placementGrid.visible = true; 

                            const normalY = pose.transform.matrix[5]; 
                            const isFloor = normalY > 0.85;

                            if (isFloor) {
                                if (gameState === GAME_STATE.SCANNING) {
                                    gameState = GAME_STATE.PLACING;
                                    updateMessage("Tap to lock", false);
                                    placementGrid.material = greenGridMat; 
                                    triggerHaptic(50); 
                                }
                            } else {
                                if (gameState === GAME_STATE.PLACING) {
                                    gameState = GAME_STATE.SCANNING;
                                    updateMessage("Scan floor to start", true);
                                    placementGrid.material = blueGridMat; 
                                }
                            }
                        } else {
                            placementGrid.visible = false; 
                            if (gameState === GAME_STATE.PLACING) {
                                gameState = GAME_STATE.SCANNING;
                                updateMessage("Scan floor to start", true);
                            }
                        }
                    }
                } else {
                    placementGrid.visible = false;
                }
            }
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateMessage(message, showIcon = false) {
            messageText.textContent = message;
            messageBox.style.display = message ? 'flex' : 'none';
            phoneIcon.style.display = showIcon ? 'block' : 'none';
        }

        function playIntroAndStart() {
            const depthOffset = -0.5; 
            const baseLift = (BOARD_HEIGHT / 2) * BLOCK_SIZE; 

            const targetPos = new THREE.Vector3();
            targetPos.setFromMatrixPosition(placementGrid.matrix);
            gameBoard.position.copy(targetPos);
            
            const cameraPos = new THREE.Vector3();
            camera.getWorldPosition(cameraPos);
            gameBoard.lookAt(cameraPos.x, gameBoard.position.y, cameraPos.z);
            
            // Treat floor as a bit lower (-0.15m)
            gameBoard.translateY(baseLift - 0.15); 
            gameBoard.translateZ(depthOffset);
            
            scene.add(gameBoard);
            placementGrid.visible = false; 
            
            introScreen.style.display = 'flex';
            introScreen.style.opacity = '0'; // Start invisible

            // Fade In
            setTimeout(() => { introScreen.style.opacity = '1'; }, 50); 

            // Fade Out
            setTimeout(() => {
                introScreen.style.opacity = '0';
                setTimeout(() => {
                    introScreen.style.display = 'none';
                    startGame();
                }, 500); 
            }, 2500); 
        }

        function startGame() {
            gameState = GAME_STATE.PLAYING;
            hudPanel.style.opacity = '1'; // Show HUD
            updateScore(0);
            
            placementGrid.visible = false;

            spawnPiece();
            gameLoopInterval = setInterval(gameTick, currentDropSpeed);
        }

        function gameTick() {
            if (!currentPiece) return;
            if (isValidMove(currentPiece, { y: 1 })) {
                currentPiece.userData.gridPos.y += 1;
                updatePiecePosition(currentPiece);
            } else {
                lockPiece();
                spawnPiece();
            }
        }
        
        function gameOver() {
            clearInterval(gameLoopInterval);
            gameState = GAME_STATE.GAME_OVER;
            
            goScore.textContent = score;
            goLevel.textContent = level;
            gameOverCard.style.display = 'flex';
            
            if (bgmLoop) bgmLoop.pause();
            playSound(gameOverSound);
        }

        function resetGame() {
            gameOverCard.style.display = 'none';
            
            for (let i = gameBoard.children.length - 1; i >= 0; i--) {
                const child = gameBoard.children[i];
                gameBoard.remove(child);
            }
            scene.remove(gameBoard); 
            gameBoard = new THREE.Group(); 

            grid = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
            score = 0;
            
            linesClearedTotal = 0;
            level = 1;
            currentDropSpeed = 1000;
            
            // Hide HUD
            hudPanel.style.opacity = '0';

            if (bgmLoop && !isMusicMuted) {
                bgmLoop.currentTime = 0;
                bgmLoop.play().catch(e => console.error("BGM restart failed:", e));
            }

            // 7. RESET TO SCANNING
            gameState = GAME_STATE.SCANNING;
            updateMessage("Scan floor to start", true);
            placementGrid.visible = false; 
        }

        function updateScore(linesCleared) {
            if (linesCleared > 0) {
                const points = { 1: 100, 2: 300, 3: 500, 4: 800 };
                score += points[linesCleared] || 0;
                
                linesClearedTotal += linesCleared;
                const newLevel = Math.floor(linesClearedTotal / 5) + 1; 
                
                if (newLevel > level) {
                    level = newLevel;
                    currentDropSpeed = Math.max(MIN_DROP_SPEED, currentDropSpeed * 0.9);
                    clearInterval(gameLoopInterval);
                    gameLoopInterval = setInterval(gameTick, currentDropSpeed);
                }

                playSound(lineClearSound);
            }
            // Update HUD
            scoreVal.textContent = score;
            levelVal.textContent = level;
        }
        
        function checkLineClears() {
            let linesCleared = 0;
            let rowsToClear = [];
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                if (grid[y].every(cell => cell > 0)) {
                    linesCleared++;
                    rowsToClear.push(y);
                }
            }
            
            if (linesCleared > 0) {
                // 4. Slow Animation (Pause Game)
                clearInterval(gameLoopInterval);

                const blocksToAnimate = [];
                gameBoard.children.forEach(block => {
                    const blockY = Math.round(BOARD_HEIGHT / 2 - 0.5 - (block.position.y / BLOCK_SIZE));
                    if (rowsToClear.includes(blockY)) {
                        blocksToAnimate.push(block);
                    }
                });

                let progress = 0;
                const duration = 1000; // 1 second
                const startTime = Date.now();

                function animateClear() {
                    const now = Date.now();
                    progress = (now - startTime) / duration;

                    if (progress < 1) {
                        blocksToAnimate.forEach(b => {
                            // Spin & Shrink
                            b.scale.setScalar(1 - progress);
                            b.rotation.y += 0.2; 
                            b.rotation.z += 0.1;
                        });
                        requestAnimationFrame(animateClear);
                    } else {
                        // Done animating, remove blocks
                        gameBoard.children = gameBoard.children.filter(block => {
                            if (block === currentPiece) return true; 
                            const blockY = Math.round(BOARD_HEIGHT / 2 - 0.5 - (block.position.y / BLOCK_SIZE));
                            return !rowsToClear.includes(blockY); 
                        });
                        
                        // Shift Grid
                        for (const y of rowsToClear.sort((a, b) => a - b)) { 
                            grid.splice(y, 1);
                            grid.unshift(Array(BOARD_WIDTH).fill(0));
                        }
                        
                        // Shift Visual Blocks
                        gameBoard.children.forEach(block => {
                            if (block === currentPiece) return; 
                            const blockY = Math.round(BOARD_HEIGHT / 2 - 0.5 - (block.position.y / BLOCK_SIZE));
                            let shift = 0;
                            for (const clearedY of rowsToClear) {
                                if (blockY < clearedY) shift++;
                            }
                            if (shift > 0) block.position.y -= shift * BLOCK_SIZE;
                        });
                        
                        updateScore(linesCleared);
                        
                        // Resume Game
                        gameLoopInterval = setInterval(gameTick, currentDropSpeed);
                    }
                }
                animateClear();
            }
        }

        function movePiece(direction) {
            if (!currentPiece) return;
            if (isValidMove(currentPiece, { x: direction })) {
                currentPiece.userData.gridPos.x += direction;
                updatePiecePosition(currentPiece);
                triggerHaptic(5); 
                // Sound removed for normal moves
            }
        }
        
        function updatePiecePosition(piece) {
            const ud = piece.userData;
            piece.position.set(
                (ud.gridPos.x - BOARD_WIDTH / 2 + 0.5) * BLOCK_SIZE,
                (BOARD_HEIGHT / 2 - 0.5 - ud.gridPos.y) * BLOCK_SIZE,
                0 
            );
        }

        function spawnPiece() {
            const typeIndex = Math.floor(Math.random() * SHAPES.length);
            const rotationIndex = 0; 
            const shape = SHAPES[typeIndex][rotationIndex];
            const color = COLORS[typeIndex + 1];
            
            const piece = new THREE.Group();
            piece.userData = { shape: shape, typeIndex: typeIndex, rotationIndex: rotationIndex, gridPos: { x: Math.floor((BOARD_WIDTH - shape[0].length) / 2), y: 0 } };
            
            const blockGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE * 0.8);
            const blockMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5, metalness: 0.1 });
            const bevelGeo = new THREE.EdgesGeometry(blockGeo);
            const bevelMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const block = new THREE.Mesh(blockGeo, blockMat);
                        const bevel = new THREE.LineSegments(bevelGeo, bevelMat);
                        block.add( bevel );
                        block.position.set(x * BLOCK_SIZE, -y * BLOCK_SIZE, 0);
                        piece.add(block);
                    }
                }
            }
            updatePiecePosition(piece);
            gameBoard.add(piece);
            currentPiece = piece;
            if (!isValidMove(currentPiece, {})) gameOver();
        }
        
        function rotatePiece() {
            if (!currentPiece) return;
            const ud = currentPiece.userData;
            const newRotationIndex = (ud.rotationIndex + 1) % SHAPES[ud.typeIndex].length;
            const newShape = SHAPES[ud.typeIndex][newRotationIndex];
            const kicks = [0, 1, -1, 2, -2]; 
            for (const kick of kicks) {
                const testPos = { x: ud.gridPos.x + kick, y: ud.gridPos.y };
                if (isValidMove(currentPiece, { shape: newShape, pos: testPos })) {
                    ud.rotationIndex = newRotationIndex;
                    ud.shape = newShape;
                    ud.gridPos.x = testPos.x; 
                    while (currentPiece.children.length) currentPiece.remove(currentPiece.children[0]);
                    
                    const color = COLORS[ud.typeIndex + 1];
                    const blockGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE * 0.8);
                    const blockMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5, metalness: 0.1 });
                    const bevelGeo = new THREE.EdgesGeometry(blockGeo);
                    const bevelMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            
                    for (let y = 0; y < newShape.length; y++) {
                        for (let x = 0; x < newShape[y].length; x++) {
                            if (newShape[y][x]) {
                                const block = new THREE.Mesh(blockGeo, blockMat);
                                const bevel = new THREE.LineSegments(bevelGeo, bevelMat);
                                block.add(bevel);
                                block.position.set(x * BLOCK_SIZE, -y * BLOCK_SIZE, 0);
                                currentPiece.add(block);
                            }
                        }
                    }
                    updatePiecePosition(currentPiece);
                    triggerHaptic(5); 
                    playSound(rotateSound);
                    return; 
                }
            }
        }
        
        function hardDrop() {
            if (!currentPiece) return;
            while (isValidMove(currentPiece, { y: 1 })) {
                currentPiece.userData.gridPos.y += 1;
            }
            updatePiecePosition(currentPiece);
            lockPiece();
            spawnPiece();
            clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameTick, currentDropSpeed); 
            triggerHaptic(20); 
            // playSound(moveSound); // Sound disabled on hard drop too
        }

        function isValidMove(piece, delta) {
            const ud = piece.userData;
            const shape = delta.shape || ud.shape;
            const newGridX = (delta.pos ? delta.pos.x : ud.gridPos.x) + (delta.x || 0);
            const newGridY = (delta.pos ? delta.pos.y : ud.gridPos.y) + (delta.y || 0);

            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = newGridX + x;
                        const boardY = newGridY + y; 
                        if (boardX < 0 || boardX >= BOARD_WIDTH) return false;
                        if (boardY >= BOARD_HEIGHT) return false;
                        if (boardY >= 0 && grid[boardY][boardX]) return false;
                    }
                }
            }
            return true;
        }

        function lockPiece() {
            if (!currentPiece) return;
            const ud = currentPiece.userData;
            const shape = ud.shape;
            const gridX = ud.gridPos.x;
            const gridY = ud.gridPos.y; 
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = gridX + x;
                        const boardY = gridY + y;
                        if (boardY < 0 || boardY >= BOARD_HEIGHT) continue; 
                        grid[boardY][boardX] = ud.typeIndex + 1;
                        
                        const color = COLORS[ud.typeIndex + 1];
                        const blockGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE * 0.8);
                        const blockMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5, metalness: 0.1 });
                        const bevelGeo = new THREE.EdgesGeometry(blockGeo);
                        const bevelMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                        const newBlock = new THREE.Mesh(blockGeo, blockMat);
                        const newBevel = new THREE.LineSegments(bevelGeo, bevelMat);
                        newBlock.add(newBevel);
                        
                        newBlock.position.set(
                            (boardX - BOARD_WIDTH / 2 + 0.5) * BLOCK_SIZE,
                            (BOARD_HEIGHT / 2 - 0.5 - boardY) * BLOCK_SIZE,
                            0
                        );
                        gameBoard.add(newBlock);
                    }
                }
            }
            gameBoard.remove(currentPiece);
            currentPiece = null;
            checkLineClears();
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * bitsPerSample / 8;
            const blockAlign = numChannels * bitsPerSample / 8;
            const dataSize = pcmData.length * 2; 
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); 
            view.setUint16(20, 1, true); 
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            for (let i = 0; i < pcmData.length; i++) view.setInt16(44 + i * 2, pcmData[i], true);
            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
        }
    </script></body>
</html>



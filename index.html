<!DOCTYPE html>
<html lang="en">

<head>
    <title>AR Tetris 3D (v10 - Logic Rebuilt)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="xr-spatial-tracking" content="true">
    
    <style>
        /* Basic reset */
        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #111;
            color: white;
            touch-action: manipulation;
        }

        /* The 3D canvas */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Base style for all UI elements */
        .ui-element {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            text-align: center;
            font-size: 1.2rem;
            font-weight: 500;
            z-index: 100;
        }

        /* Message box at the top */
        #message-box {
            top: 30px;
            display: none; /* Hidden by default */
        }
        
        /* Game Over message */
        #game-over-box {
            top: 50%;
            transform: translate(-50%, -50%);
            color: #FF4136; /* Red */
            font-size: 2rem;
            font-weight: bold;
            display: none; /* Hidden by default */
        }

        /* Score box at the top left */
        #score-box {
            top: 30px;
            left: 30px;
            transform: none; /* Override absolute center */
            color: #FFDC00; /* Gold */
            font-size: 1.5rem;
            font-weight: bold;
        }

        /* Custom AR Button */
        #custom-ar-button {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            padding: 18px 30px;
            border-radius: 50px;
            background: linear-gradient(145deg, #8a2be2, #4169e1); /* Blue-Violet gradient */
            color: white;
            font-size: 1.3rem;
            font-weight: 600;
            border: none;
            box-shadow: 0 6px 20px rgba(65, 105, 225, 0.5);
            cursor: pointer;
            z-index: 101;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
        }

        #custom-ar-button:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 8px 25px rgba(65, 105, 225, 0.7);
        }

        #custom-ar-button svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }
    </style>
</head>

<body>
    <!-- UI Elements -->
    <div id="message-box" class="ui-element">Move phone to scan floor</div>
    <div id="game-over-box" class="ui-element">GAME OVER</div>
    <div id="score-box" class="ui-element" style="display: none;">Score: 0</div>

    <!-- The fancy AR button -->
    <button id="custom-ar-button">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M19.7,3.3C17-0.9,12-1,9.3,3.3L3.3,9.3c-3.6,3.6-3.6,9.4,0,13.1C5,24,6.9,24,8.6,24s3.6-0.7,5-2l6.8-6.8l-1.9-1.9
            l-6.8,6.8c-2.1,2.1-5.6,2.1-7.8,0c-2.1-2.1-2.1-5.6,0-7.8l6-6c2.1-2.1,5.6-2.1,7.8,0c1,1,1.6,2.4,1.6,3.8c0,0.3,0.2,0.5,0.5,0.5
            s0.5-0.2,0.5-0.5C21.3,5.7,20.7,4.3,19.7,3.3z M20.7,14.7L14,21.4l1.9,1.9l6.8-6.8c2.1-2.1,2.1-5.6,0-7.8c-2.1-2.1-5.6-2.1-7.8,0
            c-1,1-1.6,2.4-1.6,3.8c0,0.3-0.2,0.5-0.5,0.5S12.3,12.5,12.3,12.2c0-2.4,1-4.7,2.7-6.4c2.6-2.6,6.9-2.5,9.5,0.1
            C28.2,9.6,24.4,18.4,20.7,14.7z"/>
        </svg>
        Launch AR
    </button>
    
    <!-- HTML Audio Elements -->
    <audio id="audio-bgm" src="/music/music.mp3" loop preload="auto"></audio>
    <audio id="audio-move" src="/music/tik.mp3" preload="auto"></audio>
    <audio id="audio-gameover" src="/music/outro.mp3" preload="auto"></audio>
    <audio id="audio-lineclear" src="/music/lineclear.mp3" preload="auto"></audio>

    <!-- JavaScript Libraries -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        
        // --- Global Variables ---
        let camera, scene, renderer;
        let controller;
        let hitTestSource = null;
        let placementGrid = null; 
        let scannerReticle = null; 
        let gameBoard = null; 
        let currentPiece = null;
        let gameLoopInterval = null;
        
        // UI Elements
        let customArButton, messageBox, scoreBox, gameOverBox;
        
        // Game state
        const GAME_STATE = {
            INITIALIZING: 0,
            SCANNING: 1,
            PLACING: 2,
            PLAYING: 3,
            GAME_OVER: 4
        };
        let gameState = GAME_STATE.INITIALIZING;
        let score = 0;

        // Game Logic (constants)
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = 0.05; // 5cm
        
        // This is the "single source of truth" for game logic
        let grid = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
        
        const SHAPES = [
            // I (y-coords 0, 1, 2, 3)
            [[[1,1,1,1]], [[1],[1],[1],[1]]],
            // O (y-coords 0, 1)
            [[[1,1],[1,1]]],
            // T (y-coords 0, 1)
            [[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]],
            // S (y-coords 0, 1)
            [[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]],
            // Z (y-coords 0, 1)
            [[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]],
            // J (y-coords 0, 1)
            [[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]],
            // L (y-coords 0, 1)
            [[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]]
        ];
        const COLORS = {
            1: 0x00F0F0, 2: 0xF0F000, 3: 0xA000F0, 4: 0x00F000, 5: 0xF00000, 6: 0x0000F0, 7: 0xF0A000,
        };

        // --- Audio Variables ---
        let moveSound, rotateSound, gameOverSound, bgmLoop, lineClearSound;

        // --- Haptics ---
        function triggerHaptic(duration = 20) {
            if (navigator.vibrate) {
                navigator.vibrate(duration);
            }
        }
        
        // --- Init Functions ---
        init();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(0, 10, 0);
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            customArButton = document.getElementById('custom-ar-button');
            messageBox = document.getElementById('message-box');
            scoreBox = document.getElementById('score-box');
            gameOverBox = document.getElementById('game-over-box');

            // --- AR Button Setup ---
            const arButton = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test', 'local-floor'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.body }
            });
            arButton.style.display = 'none'; // Hide the default button
            document.body.appendChild(arButton);

            // --- Custom Button Logic ---
            customArButton.addEventListener('click', () => {
                console.log("Custom button clicked, triggering real AR button.");
                initAudio(); // Init audio on first user gesture
                if (bgmLoop.paused) {
                    bgmLoop.play().catch(e => console.error("BGM play failed:", e));
                }
                arButton.click(); // Trigger the real AR startup
            });

            // --- Listen for AR session start ---
            renderer.xr.addEventListener('sessionstart', () => {
                if (gameState === GAME_STATE.INITIALIZING) {
                    if (!bgmLoop) initAudio(); // Failsafe
                    if (bgmLoop.paused) {
                        bgmLoop.play().catch(e => console.error("BGM play failed:", e));
                    }
                    
                    customArButton.style.display = 'none';
                    gameState = GAME_STATE.SCANNING;
                    updateMessage("Move phone to scan floor");

                    // Get hit test source
                    const currentSession = renderer.xr.getSession();
                    currentSession.requestReferenceSpace('viewer').then((referenceSpace) => {
                        currentSession.requestHitTestSource({ space: referenceSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                }
            });
            
            renderer.xr.addEventListener('sessionend', () => {
                if (bgmLoop) bgmLoop.pause();
                window.location.reload();
            });

            // --- Touch Controls ---
            let touchDown, touchX, touchY, deltaX, deltaY, lastTap = 0;
            const tapDelay = 300;
            const moveThreshold = 50;

            function onTouchStart(e) {
                if (gameState === GAME_STATE.PLACING) {
                    updateMessage("Starting Game...", true);
                    startGame();
                    return; 
                }

                if (gameState !== GAME_STATE.PLAYING) return;
                touchDown = true;
                touchX = e.touches[0].pageX;
                touchY = e.touches[0].pageY;
                deltaX = 0;
                deltaY = 0;
            }

            function onTouchMove(e) {
                if (gameState !== GAME_STATE.PLAYING || !touchDown) return;
                deltaX = e.touches[0].pageX - touchX;
                deltaY = e.touches[0].pageY - touchY;

                // Horizontal swipe (left/right)
                if (Math.abs(deltaX) > moveThreshold) {
                    const direction = deltaX > 0 ? 1 : -1;
                    // --- NEW LOGIC ---
                    if (isValidMove(currentPiece, { x: direction })) {
                        currentPiece.userData.gridPos.x += direction;
                        updatePiecePosition(currentPiece);
                        triggerHaptic(20);
                        playSound(moveSound);
                    }
                    // Reset touch start
                    touchX = e.touches[0].pageX;
                    deltaX = 0; 
                }
                
                // Vertical swipe (down)
                if (deltaY > moveThreshold * 2) {
                    hardDrop();
                    // Reset touch start
                    touchY = e.touches[0].pageY;
                    deltaY = 0;
                }
            }
            
            function onTouchEnd(e) {
                if (gameState !== GAME_STATE.PLAYING) return;
                touchDown = false;
                // Check for tap (no significant move)
                if (Math.abs(deltaX) < moveThreshold && Math.abs(deltaY) < moveThreshold) {
                    const now = new Date().getTime();
                    if (now - lastTap < tapDelay) {
                        hardDrop();
                    } else {
                        rotatePiece();
                    }
                    lastTap = now;
                }
            }
            
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });

            window.addEventListener('resize', onWindowResize);
            
            // --- Scanner / Reticle Setup ---
            scannerReticle = new THREE.Mesh(
                new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x4169E1, opacity: 0.7, transparent: true })
            );
            scannerReticle.matrixAutoUpdate = false;
            scannerReticle.visible = false;
            scene.add(scannerReticle);
            
            const gridHelper = new THREE.GridHelper(BOARD_WIDTH * BLOCK_SIZE, BOARD_WIDTH, 0x4169E1, 0x4169E1);
            const gridHelper2 = new THREE.GridHelper(BOARD_HEIGHT * BLOCK_SIZE, BOARD_HEIGHT, 0x4169E1, 0x4169E1);
            gridHelper.position.y = (BOARD_HEIGHT / 2) * BLOCK_SIZE; // Move to top
            gridHelper2.position.x = (BOARD_WIDTH / 2) * BLOCK_SIZE; // Move to side
            
            placementGrid = new THREE.Group();
            placementGrid.add(gridHelper);
            placementGrid.add(gridHelper2);
            placementGrid.matrixAutoUpdate = false;
            placementGrid.visible = false;
            // Center the grid origin
            placementGrid.position.set(
                (-BOARD_WIDTH / 2 + 0.5) * BLOCK_SIZE, 
                (-BOARD_HEIGHT / 2 + 0.5) * BLOCK_SIZE, 
                0
            );
            scene.add(placementGrid);
            
            // This group holds all *locked* blocks
            gameBoard = new THREE.Group();
            
            renderer.setAnimationLoop(animate);
        }

        // --- Audio Init for MP3s ---
        function initAudio() {
            if (bgmLoop) return; // Already initialized
            bgmLoop = document.getElementById('audio-bgm');
            moveSound = document.getElementById('audio-move');
            rotateSound = document.getElementById('audio-move'); 
            gameOverSound = document.getElementById('audio-gameover');
            lineClearSound = document.getElementById('audio-lineclear');
            
            bgmLoop.volume = 0.3;
            moveSound.volume = 0.8;
            rotateSound.volume = 0.8;
            gameOverSound.volume = 0.7;
            if(lineClearSound) lineClearSound.volume = 0.7;
        }

        // --- Helper function to play sounds ---
        function playSound(audioElement) {
            if (!audioElement) return;
            audioElement.currentTime = 0; // Rewind to start
            audioElement.play().catch(e => console.error("Sound play failed:", e));
        }

        // --- Game Loop ---
        function animate(timestamp, frame) {
            if (frame) {
                const session = renderer.xr.getSession();
                if (!session) {
                    renderer.render(scene, camera);
                    return;
                }

                // Logic for scanning and placing
                if (gameState === GAME_STATE.SCANNING || gameState === GAME_STATE.PLACING) {
                    if (hitTestSource) {
                        const hitTestResults = frame.getHitTestResults(hitTestSource);
                        if (hitTestResults.length > 0) {
                            const hit = hitTestResults[0];
                            const referenceSpace = renderer.xr.getReferenceSpace();
                            const pose = hit.getPose(referenceSpace);
                            
                            // Show the MESH grid
                            placementGrid.matrix.fromArray(pose.transform.matrix);
                            placementGrid.visible = true;
                            scannerReticle.visible = false;
                            
                            if (gameState === GAME_STATE.SCANNING) {
                                gameState = GAME_STATE.PLACING;
                                updateMessage("Tap screen to lock floor");
                            }
                        } else {
                            // No hit, show the RING reticle
                            placementGrid.visible = false;
                            scannerReticle.visible = true;
                            const pose = frame.getViewerPose(renderer.xr.getReferenceSpace());
                            if (pose) {
                                const transform = new THREE.Matrix4().fromArray(pose.views[0].transform.matrix);
                                const forward = new THREE.Vector3(0, 0, -1).applyMatrix4(transform);
                                const position = new THREE.Vector3().setFromMatrixPosition(transform);
                                scannerReticle.position.copy(position).add(forward.multiplyScalar(2));
                                scannerReticle.lookAt(position);
                            }
                        }
                    }
                }
            }
            renderer.render(scene, camera);
        }
        
        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Game State Functions ---
        function updateMessage(message, autoHide = false) {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            if (autoHide) {
                setTimeout(() => { messageBox.style.display = 'none'; }, 2000);
            }
        }

        function startGame() {
            gameState = GAME_STATE.PLAYING;
            scoreBox.style.display = 'block';
            updateScore(0);
            
            // Lock the gameBoard to the placementGrid's position
            gameBoard.applyMatrix4(placementGrid.matrix);
            scene.add(gameBoard);
            
            placementGrid.visible = false;
            scannerReticle.visible = false;
            
            spawnPiece();
            gameLoopInterval = setInterval(gameTick, 1000);
        }

        // --- NEW: Rebuilt Game Tick ---
        function gameTick() {
            if (!currentPiece) return;

            if (isValidMove(currentPiece, { y: 1 })) {
                // Move down logically
                currentPiece.userData.gridPos.y += 1;
                updatePiecePosition(currentPiece);
            } else {
                // Landed
                lockPiece();
                spawnPiece();
            }
        }
        
        function gameOver() {
            clearInterval(gameLoopInterval);
            gameState = GAME_STATE.GAME_OVER;
            gameOverBox.style.display = 'block';
            
            if (bgmLoop) bgmLoop.pause();
            playSound(gameOverSound);
        }

        function updateScore(linesCleared) {
            const points = { 1: 100, 2: 300, 3: 500, 4: 800 };
            if (linesCleared > 0) {
                score += points[linesCleared] || 0;
                playSound(lineClearSound);
                
                // Line Clear Flash Effect
                const flash = document.createElement('div');
                flash.style.position = 'absolute';
                flash.style.top = '0';
                flash.style.left = '0';
                flash.style.width = '100%';
                flash.style.height = '100%';
                flash.style.backgroundColor = 'rgba(255, 255, 255, 0.7)';
                flash.style.zIndex = '999';
                document.body.appendChild(flash);
                setTimeout(() => document.body.removeChild(flash), 100);
            }
            scoreBox.textContent = `Score: ${score}`;
        }
        
        // --- NEW: Helper to sync 3D pos from logical pos ---
        function updatePiecePosition(piece) {
            const ud = piece.userData;
            // Y-axis is inverted: gridY 0 is at the top, so 3D y is high.
            piece.position.set(
                (ud.gridPos.x - BOARD_WIDTH / 2 + 0.5) * BLOCK_SIZE,
                (BOARD_HEIGHT / 2 - 0.5 - ud.gridPos.y) * BLOCK_SIZE,
                0
            );
        }

        // --- NEW: Rebuilt Piece Spawning ---
        function spawnPiece() {
            const typeIndex = Math.floor(Math.random() * SHAPES.length);
            const rotationIndex = 0; // Always spawn in default rotation
            const shape = SHAPES[typeIndex][rotationIndex];
            const color = COLORS[typeIndex + 1];
            
            const piece = new THREE.Group();
            piece.userData = {
                shape: shape,
                typeIndex: typeIndex,
                rotationIndex: rotationIndex,
                gridPos: {
                    // Start at top-middle
                    x: Math.floor((BOARD_WIDTH - shape[0].length) / 2),
                    y: 0 // Logical Y starts at 0 (top)
                }
            };
            
            // Create blocks
            const blockGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE * 0.8);
            const blockMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5, metalness: 0.1 });
            const bevelGeo = new THREE.EdgesGeometry(blockGeo);
            const bevelMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const block = new THREE.Mesh(blockGeo, blockMat);
                        const bevel = new THREE.LineSegments(bevelGeo, bevelMat);
                        block.add(bevel);
                        // Position relative to the piece's group origin
                        block.position.set(
                            x * BLOCK_SIZE,
                            -y * BLOCK_SIZE, // y is inverted in shape array
                            0
                        );
                        piece.add(block);
                    }
                }
            }

            // Set initial 3D position based on logical grid position
            updatePiecePosition(piece);

            // Add to scene (not gameBoard, gameBoard is for locked pieces)
            scene.add(piece);
            currentPiece = piece;
            
            // --- NEW: Game Over Check ---
            // Check if the spawn location is valid. If not, game over.
            if (!isValidMove(currentPiece, {})) {
                gameOver();
            }
        }
        
        // --- NEW: Rebuilt Rotate ---
        function rotatePiece() {
            if (!currentPiece) return;
            
            const ud = currentPiece.userData;
            const newRotationIndex = (ud.rotationIndex + 1) % SHAPES[ud.typeIndex].length;
            const newShape = SHAPES[ud.typeIndex][newRotationIndex];
            
            // Test kicks
            const kicks = [0, 1, -1, 2, -2]; 
            for (const kick of kicks) {
                const testPos = { 
                    x: ud.gridPos.x + kick, 
                    y: ud.gridPos.y // y doesn't kick
                };

                // Check if this new shape at this new position is valid
                if (isValidMove(currentPiece, { shape: newShape, pos: testPos })) {
                    // It's valid! Apply the rotation.
                    ud.rotationIndex = newRotationIndex;
                    ud.shape = newShape;
                    ud.gridPos.x = testPos.x; // Apply the kick
                    
                    // Re-create the visual blocks
                    while (currentPiece.children.length) {
                        currentPiece.remove(currentPiece.children[0]);
                    }
                    const color = COLORS[ud.typeIndex + 1];
                    const blockGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE * 0.8);
                    const blockMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5, metalness: 0.1 });
                    const bevelGeo = new THREE.EdgesGeometry(blockGeo);
                    const bevelMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            
                    for (let y = 0; y < newShape.length; y++) {
                        for (let x = 0; x < newShape[y].length; x++) {
                            if (newShape[y][x]) {
                                const block = new THREE.Mesh(blockGeo, blockMat);
                                const bevel = new THREE.LineSegments(bevelGeo, bevelMat);
                                block.add(bevel);
                                block.position.set(
                                    x * BLOCK_SIZE,
                                    -y * BLOCK_SIZE,
                                    0
                                );
                                currentPiece.add(block);
                            }
                        }
                    }
                    
                    // Update 3D position from new logical position
                    updatePiecePosition(currentPiece);
                    
                    triggerHaptic(30);
                    playSound(rotateSound);
                    return; // Rotation successful
                }
            }
            // No kicks worked
        }
        
        // --- NEW: Rebuilt Hard Drop ---
        function hardDrop() {
            if (!currentPiece) return;
            
            // Find lowest valid logical Y position
            while (isValidMove(currentPiece, { y: 1 })) {
                currentPiece.userData.gridPos.y += 1;
            }
            
            // Snap 3D position to this final spot
            updatePiecePosition(currentPiece);
            
            // Lock and spawn next
            lockPiece();
            spawnPiece();
            
            // Reset game tick
            clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameTick, 1000);
            
            triggerHaptic(50);
            playSound(moveSound);
        }

        // --- NEW: Rebuilt Collision Logic ---
        function isValidMove(piece, delta) {
            const ud = piece.userData;
            const shape = delta.shape || ud.shape;
            
            // Get test position
            const newGridX = (delta.pos ? delta.pos.x : ud.gridPos.x) + (delta.x || 0);
            const newGridY = (delta.pos ? delta.pos.y : ud.gridPos.y) + (delta.y || 0);

            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    // If this is a block in the shape
                    if (shape[y][x]) {
                        // Calculate its potential position on the main grid
                        const boardX = newGridX + x;
                        const boardY = newGridY + y; // y is 0,1,2,3...

                        // 1. Check walls
                        if (boardX < 0 || boardX >= BOARD_WIDTH) {
                            return false;
                        }
                        
                        // 2. Check floor
                        if (boardY >= BOARD_HEIGHT) {
                            return false;
                        }
                        
                        // 3. Check other blocks (only if within bounds)
                        if (boardY >= 0 && grid[boardY][boardX]) {
                            return false;
                        }
                    }
                }
            }
            // All checks passed
            return true;
        }

        // --- NEW: Rebuilt Lock Piece ---
        function lockPiece() {
            if (!currentPiece) return;
            
            const ud = currentPiece.userData;
            const shape = ud.shape;
            const gridX = ud.gridPos.x;
            const gridY = ud.gridPos.y; // This is the final, correct logical Y
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = gridX + x;
                        const boardY = gridY + y;
                        
                        // This should be impossible if isValidMove is correct
                        // but good to check
                        if (boardY < 0 || boardY >= BOARD_HEIGHT) {
                            continue; 
                        }
                        
                        // Add to collision grid
                        grid[boardY][boardX] = ud.typeIndex + 1;
                        
                        // Create a new, stationary block and add it to the gameBoard
                        const color = COLORS[ud.typeIndex + 1];
                        const blockGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE * 0.8);
                        const blockMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5, metalness: 0.1 });
                        const bevelGeo = new THREE.EdgesGeometry(blockGeo);
                        const bevelMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            
                        const newBlock = new THREE.Mesh(blockGeo, blockMat);
                        const newBevel = new THREE.LineSegments(bevelGeo, bevelMat);
                        newBlock.add(newBevel);
                        
                        // Set its position *in gameBoard's local space*
                        newBlock.position.set(
                            (boardX - BOARD_WIDTH / 2 + 0.5) * BLOCK_SIZE,
                            (BOARD_HEIGHT / 2 - 0.5 - boardY) * BLOCK_SIZE,
                            0
                        );
                        gameBoard.add(newBlock);
                    }
                }
            }
            
            // Remove the moving piece
            scene.remove(currentPiece);
            currentPiece = null;
            
            checkLineClears();
        }

        // --- NEW: Rebuilt Line Clear ---
        function checkLineClears() {
            let linesCleared = 0;
            let rowsToClear = [];
            
            // Check from bottom-up
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                if (grid[y].every(cell => cell > 0)) {
                    // Full row!
                    linesCleared++;
                    rowsToClear.push(y);
                }
            }

            if (linesCleared > 0) {
                // Filter the 3D blocks
                gameBoard.children = gameBoard.children.filter(block => {
                    // Calculate logical Y from 3D Y
                    const blockY = Math.round(BOARD_HEIGHT / 2 - 0.5 - (block.position.y / BLOCK_SIZE));
                    return !rowsToClear.includes(blockY); // Keep if NOT in cleared rows
                });
                
                // Remove cleared rows from grid and add new ones at top
                for (const y of rowsToClear.sort((a, b) => a - b)) { // Sort to remove from bottom-up
                    grid.splice(y, 1);
                    grid.unshift(Array(BOARD_WIDTH).fill(0));
                }
                
                // Shift down all remaining 3D blocks
                gameBoard.children.forEach(block => {
                    const blockY = Math.round(BOARD_HEIGHT / 2 - 0.5 - (block.position.y / BLOCK_SIZE));
                    let shift = 0;
                    for (const clearedY of rowsToClear) {
                        if (blockY < clearedY) { // If block was above a cleared line
                            shift++;
                        }
                    }
                    if (shift > 0) {
                        // Move down in 3D space
                        block.position.y -= shift * BLOCK_SIZE;
                    }
                });
                
                updateScore(linesCleared);
            }
        }
    </script></body>
</html>



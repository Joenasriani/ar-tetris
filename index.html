<!DOCTYPE html>
<html>
<head>
    <title>AR Tetris 3D</title>
    <!-- Critical for mobile and AR -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            /* Hide overflow to prevent scrollbars during AR session */
            overflow: hidden;
            background-color: #000;
        }

        /* The AR button generated by Three.js */
        #ARButton {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background-color: #fff;
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            z-index: 100;
        }
        
        /* Container for UI messages like "Scan floor" */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            pointer-events: none; /* Allows taps to go through to the canvas */
        }

        #message {
            font-size: 24px;
            font-weight: bold;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 12px;
            /* Add a stroke for readability against the camera feed */
            text-shadow: 0 0 8px black, 0 0 8px black, 0 0 8px black;
        }

        #score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 28px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 8px black, 0 0 8px black;
            z-index: 100;
            display: none; /* Hidden until game starts */
        }
    </style>
</head>
<body>
    <!-- UI Elements -->
    <div id="ui-container">
        <div id="message">Loading AR...</div>
    </div>
    <div id="score-display">Score: 0</div>

    <!-- 
      Import Map: This tells the browser where to find the "three" and "three/addons/" modules.
      This is the modern way to handle JS modules without a bundler.
    -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
        }
    }
    </script>

    <!-- Main Game Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // --- GLOBAL VARIABLES ---
        let camera, scene, renderer;
        let controller;
        let hitTestSource = null;
        let localSpace = null;
        let reticle; // This will be our "blueprint" scanner
        let gameBoard = new THREE.Group(); // Parent for all locked pieces
        let activePiece = null;
        
        let messageEl = document.getElementById('message');
        let scoreEl = document.getElementById('score-display');

        // Game State
        const GAME_STATE = {
            SCANNING: 'SCANNING',
            PLACING: 'PLACING',
            PLAYING: 'PLAYING',
            GAME_OVER: 'GAME_OVER'
        };
        let gameState = GAME_STATE.SCANNING;
        
        // Tetris Grid Logic
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = 0.05; // 5cm blocks (approx 2 inches, good for mobile AR)
        const SPAWN_HEIGHT = BOARD_HEIGHT * BLOCK_SIZE * 2; // "Way up high"
        let fallSpeed = 1000; // Milliseconds per drop
        let fastDropSpeed = 50;
        let currentFallSpeed = fallSpeed;
        let lastFallTime = 0;
        let score = 0;
        
        // 2D array to store locked blocks. `grid[y][x]`
        let grid = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(null));

        // Touch Controls
        let lastTapTime = 0;
        
        // --- 3D / TETRIS DEFINITIONS ---

        const BLOCK_GEOMETRY = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        
        const COLORS = {
            'I': 0x00ffff, // Cyan
            'O': 0xffff00, // Yellow
            'T': 0x800080, // Purple
            'S': 0x00ff00, // Green
            'Z': 0xff0000, // Red
            'J': 0x0000ff, // Blue
            'L': 0xffa500  // Orange
        };

        const MATERIALS = {};
        for (const key in COLORS) {
            MATERIALS[key] = new THREE.MeshLambertMaterial({ color: COLORS[key] });
        }

        // Tetrimino shapes and their pivot points for rotation
        const PIECES = {
            'I': {
                shape: [[0, 0, 0], [1, 0, 0], [2, 0, 0], [3, 0, 0]],
                pivot: [1.5, 0.5, 0],
                type: 'I'
            },
            'O': {
                shape: [[0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 0]],
                pivot: [0.5, 0.5, 0],
                type: 'O'
            },
            'T': {
                shape: [[0, 0, 0], [1, 0, 0], [2, 0, 0], [1, 1, 0]],
                pivot: [1, 0, 0],
                type: 'T'
            },
            'S': {
                shape: [[1, 0, 0], [2, 0, 0], [0, 1, 0], [1, 1, 0]],
                pivot: [1, 0, 0],
                type: 'S'
            },
            'Z': {
                shape: [[0, 0, 0], [1, 0, 0], [1, 1, 0], [2, 1, 0]],
                pivot: [1, 0, 0],
                type: 'Z'
            },
            'J': {
                shape: [[0, 1, 0], [1, 1, 0], [2, 1, 0], [2, 0, 0]],
                pivot: [1, 1, 0],
                type: 'J'
            },
            'L': {
                shape: [[0, 0, 0], [1, 0, 0], [2, 0, 0], [0, 1, 0]],
                pivot: [1, 0, 0],
                type: 'L'
            }
        };

        // --- INITIALIZATION ---

        init();
        
        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
            
            // Add game board to scene (it's empty and at 0,0,0 for now)
            scene.add(gameBoard);

            // AR Button Setup
            messageEl.textContent = "Please install ARCore and use Chrome";
            const arButton = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test', 'dom-overlay'],
                domOverlay: { root: document.body }
            });

            arButton.addEventListener('click', () => {
                messageEl.textContent = "Move your phone to scan the floor";
            });
            document.body.appendChild(arButton);
            
            // Controller for Tapping
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            // Reticle (Blueprint Scanner)
            createReticle();
            
            // Touch Controls for Gameplay
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });

            // Handle window resizing
            window.addEventListener('resize', onWindowResize);
            
            // Start the render loop
            renderer.setAnimationLoop(animate);
        }

        // --- AR / WEBXR FUNCTIONS ---

        function createReticle() {
            // This is our "blueprint" scanner and floor-locking target.
            // It's a grid outline of the 10x20 board.
            const reticleMaterial = new THREE.MeshBasicMaterial({ color: 0x007bff, wireframe: true });
            const reticleGeometry = new THREE.PlaneGeometry(BOARD_WIDTH * BLOCK_SIZE, BOARD_HEIGHT * BLOCK_SIZE);
            reticleGeometry.rotateX(-Math.PI / 2); // Rotate to be flat on the floor
            reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
            
            // Add lines for the grid
            const linesMaterial = new THREE.LineBasicMaterial({ color: 0x007bff, transparent: true, opacity: 0.5 });
            
            // Vertical lines
            for (let i = 0; i <= BOARD_WIDTH; i++) {
                const x = (i - BOARD_WIDTH / 2) * BLOCK_SIZE;
                const points = [];
                points.push(new THREE.Vector3(x, 0, -BOARD_HEIGHT / 2 * BLOCK_SIZE));
                points.push(new THREE.Vector3(x, 0,  BOARD_HEIGHT / 2 * BLOCK_SIZE));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                reticle.add(new THREE.Line(geometry, linesMaterial));
            }
            // Horizontal lines
            for (let i = 0; i <= BOARD_HEIGHT; i++) {
                const z = (i - BOARD_HEIGHT / 2) * BLOCK_SIZE;
                const points = [];
                points.push(new THREE.Vector3(-BOARD_WIDTH / 2 * BLOCK_SIZE, 0, z));
                points.push(new THREE.Vector3( BOARD_WIDTH / 2 * BLOCK_SIZE, 0, z));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                reticle.add(new THREE.Line(geometry, linesMaterial));
            }
            
            reticle.visible = false;
            scene.add(reticle);
        }

        // --- EVENT HANDLERS ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // `onSelect` is triggered by the controller (a screen tap in AR)
        // We only use this for *locking the floor*
        function onSelect() {
            if (gameState === GAME_STATE.PLACING && reticle.visible) {
                // Lock the game board to the reticle's position
                gameBoard.position.setFromMatrixPosition(reticle.matrix);
                gameBoard.quaternion.setFromRotationMatrix(reticle.matrix);
                
                // Hide reticle and message
                reticle.visible = false;
                scene.remove(reticle);
                messageEl.style.display = 'none';
                scoreEl.style.display = 'block';

                // Stop hit-testing
                hitTestSource.cancel();
                hitTestSource = null;
                
                // Start the game!
                gameState = GAME_STATE.PLAYING;
                spawnNewPiece();
            }
        }
        
        // `onTouchStart` is for all game controls
        function onTouchStart(event) {
            if (gameState !== GAME_STATE.PLAYING || !activePiece) {
                return;
            }

            event.preventDefault();

            const touch = event.touches[0];
            const touchX = touch.clientX / window.innerWidth;
            const now = Date.now();

            // Check for Double Tap (Fast Drop)
            if (now - lastTapTime < 300) {
                currentFallSpeed = fastDropSpeed;
            } else {
                // Single Tap
                if (touchX < 0.33) {
                    // Left 1/3 of screen
                    moveActivePiece(-1, 0); // Move Left
                } else if (touchX > 0.66) {
                    // Right 1/3 of screen
                    moveActivePiece(1, 0); // Move Right
                } else {
                    // Middle 1/3 of screen
                    rotateActivePiece(); // Rotate
                }
            }
            
            lastTapTime = now;
        }


        // --- GAME LOOP ---

        function animate(timestamp, frame) {
            // `frame` is only available during an active WebXR session
            if (frame) {
                const session = renderer.xr.getSession();

                if (gameState === GAME_STATE.SCANNING) {
                    messageEl.textContent = "Move your phone to scan the floor";
                }
                
                // 1. Handle AR Hit-Testing (Floor finding)
                if (gameState === GAME_STATE.SCANNING || gameState === GAME_STATE.PLACING) {
                    if (!hitTestSource) {
                        // We need to request a hit-test source once
                        session.requestReferenceSpace('viewer').then((referenceSpace) => {
                            session.requestHitTestSource({ space: referenceSpace }).then((source) => {
                                hitTestSource = source;
                                gameState = GAME_STATE.PLACING; // Now we're ready to place
                            });
                        });
                    }

                    if (hitTestSource) {
                        const hitTestResults = frame.getHitTestResults(hitTestSource);
                        if (hitTestResults.length > 0) {
                            const hit = hitTestResults[0];
                            const referenceSpace = renderer.xr.getReferenceSpace();
                            const pose = hit.getPose(referenceSpace);
                            
                            reticle.visible = true;
                            reticle.matrix.fromArray(pose.transform.matrix);
                            messageEl.textContent = "Tap screen to lock floor";
                        } else {
                            reticle.visible = false;
                            messageEl.textContent = "Scanning... point at a flat surface";
                        }
                    }
                }

                // 2. Handle Game Logic
                if (gameState === GAME_STATE.PLAYING) {
                    updateGame(timestamp);
                }
            }

            // Render the scene
            renderer.render(scene, camera);
        }
        
        // --- TETRIS GAME LOGIC ---

        function updateGame(timestamp) {
            if (timestamp > lastFallTime + currentFallSpeed) {
                if (activePiece) {
                    // Try to move down
                    if (!checkCollision(0, -1, activePiece.gridPos, activePiece.shape)) {
                        // Move is valid
                        activePiece.gridPos.y--;
                        activePiece.position.y = activePiece.gridPos.y * BLOCK_SIZE;
                    } else {
                        // Collision! Lock the piece
                        lockPiece();
                        checkLineClears();
                        spawnNewPiece();
                        if (checkCollision(0, 0, activePiece.gridPos, activePiece.shape)) {
                            // Game Over
                            gameState = GAME_STATE.GAME_OVER;
                            messageEl.textContent = `Game Over! Score: ${score}`;
                            messageEl.style.display = 'flex';
                            activePiece = null;
                        }
                    }
                }
                lastFallTime = timestamp;
            }
        }
        
        function spawnNewPiece() {
            const pieceNames = Object.keys(PIECES);
            const randomPieceName = pieceNames[Math.floor(Math.random() * pieceNames.length)];
            const pieceData = PIECES[randomPieceName];
            
            activePiece = new THREE.Group();
            
            const material = MATERIALS[pieceData.type];
            
            pieceData.shape.forEach(offset => {
                const block = new THREE.Mesh(BLOCK_GEOMETRY, material);
                block.position.set(
                    offset[0] * BLOCK_SIZE,
                    offset[1] * BLOCK_SIZE,
                    offset[2] * BLOCK_SIZE
                );
                activePiece.add(block);
            });
            
            // Store data on the group
            activePiece.shape = pieceData.shape.map(arr => [...arr]); // Deep copy
            activePiece.pivot = pieceData.pivot.map(v => v * BLOCK_SIZE);
            activePiece.gridPos = { x: Math.floor(BOARD_WIDTH / 2) - 1, y: BOARD_HEIGHT - 2 };
            
            // Center the pivot
            const pivotOffset = new THREE.Vector3(activePiece.pivot[0], activePiece.pivot[1], activePiece.pivot[2]);
            activePiece.children.forEach(block => {
                block.position.sub(pivotOffset);
            });
            
            // Position the piece "way up high" and relative to the board
            activePiece.position.set(
                (activePiece.gridPos.x + 0.5) * BLOCK_SIZE,
                SPAWN_HEIGHT, // Start "way up high"
                0.5 * BLOCK_SIZE // Center on Z
            );
            
            // Add to the gameBoard group (which is on the floor)
            gameBoard.add(activePiece);
            
            // Reset fall speed
            currentFallSpeed = fallSpeed;
        }

        function moveActivePiece(dx, dy) {
            if (!activePiece) return;
            
            if (!checkCollision(dx, dy, activePiece.gridPos, activePiece.shape)) {
                activePiece.gridPos.x += dx;
                activePiece.gridPos.y += dy;
                
                // Update 3D position
                activePiece.position.x = (activePiece.gridPos.x + 0.5) * BLOCK_SIZE;
                activePiece.position.y = activePiece.gridPos.y * BLOCK_SIZE;
            }
        }
        
        function rotateActivePiece() {
            if (!activePiece) return;
            
            // Create a temporary new shape by rotating the current one
            const pivot = activePiece.pivot.map(v => v / BLOCK_SIZE); // Get pivot in grid units
            let newShape = [];
            
            for (const block of activePiece.shape) {
                // Translate to origin
                let x = block[0];
                let y = block[1];
                
                // Rotate 90 degrees clockwise: (x, y) -> (y, -x)
                let newX = y;
                let newY = -x;
                
                newShape.push([newX, newY, 0]);
            }
            
            // Check for collision with new shape
            if (!checkCollision(0, 0, activePiece.gridPos, newShape)) {
                // Rotation is valid, apply it
                activePiece.shape = newShape;
                activePiece.rotation.z -= Math.PI / 2; // Rotate the parent group
            }
            // TODO: Add wall-kicking for more complex rotation
        }

        // Check if a move or rotation is valid
        function checkCollision(dx, dy, pos, shape) {
            for (const block of shape) {
                const gridX = pos.x + block[0] + dx;
                const gridY = pos.y + block[1] + dy;

                // 1. Check Wall Collisions
                if (gridX < 0 || gridX >= BOARD_WIDTH) {
                    return true; // Hit side wall
                }
                // 2. Check Floor Collision
                if (gridY < 0) {
                    return true; // Hit floor
                }
                // 3. Check Other Piece Collision
                if (gridY < BOARD_HEIGHT && grid[gridY][gridX]) {
                    return true; // Hit another block
                }
            }
            return false; // No collision
        }
        
        function lockPiece() {
            if (!activePiece) return;

            // Add each block of the active piece to the main gameBoard and the grid
            for (const block of activePiece.shape) {
                const gridX = activePiece.gridPos.x + block[0];
                const gridY = activePiece.gridPos.y + block[1];

                if (gridY >= 0 && gridY < BOARD_HEIGHT && gridX >= 0 && gridX < BOARD_WIDTH) {
                    // Get the block's world position before detaching
                    const worldPos = new THREE.Vector3();
                    activePiece.children[0].getWorldPosition(worldPos); // Just need one block's world pos
                    
                    // Create a new mesh, lock it to the gameBoard
                    const blockMesh = activePiece.children[0];
                    activePiece.remove(blockMesh); // Remove from active piece
                    
                    // Convert its position relative to the gameBoard parent
                    gameBoard.attach(blockMesh);
                    
                    // Store it in our logical grid
                    grid[gridY][gridX] = blockMesh; 
                }
            }
            
            // Remove the (now empty) activePiece group
            gameBoard.remove(activePiece);
            activePiece = null;
        }
        
        function checkLineClears() {
            let linesCleared = 0;
            
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                let isLineFull = true;
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (!grid[y][x]) {
                        isLineFull = false;
                        break;
                    }
                }

                if (isLineFull) {
                    linesCleared++;
                    
                    // Remove all 3D meshes in this row
                    for (let x = 0; x < BOARD_WIDTH; x++) {
                        gameBoard.remove(grid[y][x]);
                        grid[y][x].geometry.dispose();
                        grid[y][x].material.dispose();
                    }
                    
                    // Shift all rows above this one down
                    for (let row = y; row < BOARD_HEIGHT - 1; row++) {
                        for (let x = 0; x < BOARD_WIDTH; x++) {
                            grid[row][x] = grid[row + 1][x];
                            // Move the 3D mesh down
                            if (grid[row][x]) {
                                grid[row][x].position.y -= BLOCK_SIZE;
                            }
                        }
                    }
                    
                    // Clear the top row
                    grid[BOARD_HEIGHT - 1] = Array(BOARD_WIDTH).fill(null);
                    
                    // We need to re-check this row index
                    y--;
                }
            }
            
            if (linesCleared > 0) {
                // Update Score
                const points = [0, 100, 300, 500, 800]; // 0, 1, 2, 3, 4 lines
                score += points[linesCleared];
                scoreEl.textContent = `Score: ${score}`;
                
                // Increase speed
                fallSpeed = Math.max(200, fallSpeed * 0.95);
            }
        }

    </script>
</body>
</html>


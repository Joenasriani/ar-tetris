<!DOCTYPE html>
<html lang="en">

<head>
    <title>AR Tetris 3D (v36 - Music Toggle)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="xr-spatial-tracking" content="true">
    
    <!-- Load Google Font: Roboto (Thin weight) -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400;500&display=swap" rel="stylesheet">

    <style>
        /* --- Load Custom Font --- */
        @font-face {
            font-family: 'TetrisBlocks';
            src: url('font/TetrisBlocks-P99g.ttf') format('truetype');
        }

        /* Basic reset */
        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Roboto', sans-serif; 
            font-weight: 300; 
            background-color: #111;
            color: white;
            touch-action: none; 
        }

        /* The 3D canvas */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Force-hide the default button */
        #default-ar-button {
            display: none !important;
            visibility: hidden !important;
        }

        /* UI Elements */
        .ui-element {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            text-align: center;
            font-size: 1.5rem; 
            font-weight: 500;
            z-index: 100;
            pointer-events: none; 
            letter-spacing: 1px;
            font-family: 'TetrisBlocks', sans-serif; 
        }

        #message-box {
            top: 30px;
            display: none;
            max-width: 90%;
        }
        
        #game-over-box {
            top: 40%; 
            transform: translate(-50%, -50%);
            color: #FF4136;
            font-size: 3rem; 
            font-weight: bold;
            display: none;
            text-shadow: 2px 2px 0px #000;
        }

        #score-box {
            top: 30px;
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Center align */
            color: #FFDC00;
            font-size: 1.8rem;
            font-weight: bold;
            text-shadow: 2px 2px 0px #000;
            display: none; /* Hidden initially */
        }
        
        #level-box {
            top: 70px;
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Center align */
            color: #00FFFF; 
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 1px 1px 0px #000;
            display: none; 
            font-family: 'TetrisBlocks', sans-serif;
        }

        /* Custom AR Button */
        #custom-ar-button {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            padding: 18px 30px;
            border-radius: 50px;
            background: linear-gradient(145deg, #8a2be2, #4169e1);
            color: white;
            font-family: 'TetrisBlocks', sans-serif;
            font-size: 1.5rem;
            font-weight: 600;
            border: none;
            box-shadow: 0 6px 20px rgba(65, 105, 225, 0.5);
            cursor: pointer;
            z-index: 101;
            transition: all 0.3s ease;
            pointer-events: auto; 
            text-transform: uppercase;
        }

        #custom-ar-button:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 8px 25px rgba(65, 105, 225, 0.7);
        }
        
        /* Gemini Tip Button */
        #gemini-tip-button {
            position: absolute;
            top: calc(50% + 20px); 
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            border-radius: 20px;
            background: linear-gradient(145deg, #1e90ff, #00bfff);
            color: white;
            font-family: 'TetrisBlocks', sans-serif;
            font-size: 1.2rem;
            font-weight: 600;
            border: none;
            box-shadow: 0 4px 15px rgba(30, 144, 255, 0.5);
            cursor: pointer;
            z-index: 101;
            transition: all 0.3s ease;
            pointer-events: auto;
            display: none;
        }
        
        #gemini-tip-button:disabled {
            background: #555;
            opacity: 0.7;
            cursor: not-allowed;
        }

        /* Replay Button */
        #replay-button {
            position: absolute;
            top: calc(50% + 90px); 
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 30px;
            border-radius: 20px;
            background: linear-gradient(145deg, #2ecc71, #27ae60); 
            color: white;
            font-family: 'TetrisBlocks', sans-serif;
            font-size: 1.2rem;
            font-weight: 600;
            border: none;
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.5);
            cursor: pointer;
            z-index: 101;
            transition: all 0.3s ease;
            pointer-events: auto;
            display: none;
            text-transform: uppercase;
        }

        #replay-button:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 6px 20px rgba(46, 204, 113, 0.7);
        }

        /* --- NEW: Music Toggle Button --- */
        #music-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 102; /* Higher than others */
            pointer-events: auto;
            transition: background-color 0.2s;
        }

        #music-toggle:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

        #music-toggle svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

    </style>
</head>

<body>
    <!-- UI -->
    <div id="message-box" class="ui-element">Scan floor to start</div>
    <div id="game-over-box" class="ui-element">GAME OVER</div>
    <div id="score-box" class="ui-element">Score: 0</div>
    <div id="level-box" class="ui-element">Level: 1</div>

    <!-- NEW: Music Toggle Button -->
    <button id="music-toggle" aria-label="Toggle Music">
        <!-- Icon: Sound On -->
        <svg id="icon-sound-on" viewBox="0 0 24 24">
            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
        </svg>
        <!-- Icon: Sound Off (Hidden by default) -->
        <svg id="icon-sound-off" viewBox="0 0 24 24" style="display: none;">
            <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73 4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
        </svg>
    </button>

    <button id="custom-ar-button">
        Launch AR
    </button>
    
    <button id="gemini-tip-button">
        Get Tip
    </button>

    <button id="replay-button">
        Play Again
    </button>
    
    <!-- Audio -->
    <audio id="audio-tts" preload="auto" playsinline></audio>
    <audio id="audio-bgm" src="/music/music.mp3" loop preload="auto" playsinline></audio>
    <audio id="audio-move" src="/music/tik.mp3" preload="auto" playsinline></audio>
    <audio id="audio-gameover" src="/music/outro.mp3" preload="auto" playsinline></audio>
    <audio id="audio-lineclear" src="/music/lineclear.mp3" preload="auto" playsinline></audio>

    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        
        // --- Global Variables ---
        let camera, scene, renderer;
        let hitTestSource = null;
        let placementGrid = null; 
        let gameBoard = null; 
        let currentPiece = null;
        let gameLoopInterval = null;
        
        let customArButton, messageBox, scoreBox, levelBox, gameOverBox, geminiTipButton, replayButton, musicToggleBtn;
        let iconSoundOn, iconSoundOff;
        
        const GAME_STATE = {
            INITIALIZING: 0,
            SCANNING: 1,
            PLACING: 2,
            PLAYING: 3,
            GAME_OVER: 4
        };
        let gameState = GAME_STATE.INITIALIZING;
        let score = 0;
        
        // --- Level Variables ---
        let level = 1;
        let linesClearedTotal = 0;
        let currentDropSpeed = 1000; 
        const MIN_DROP_SPEED = 100; 

        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20; 
        const BLOCK_SIZE = 0.1; 
        
        let grid = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
        
        const SHAPES = [
            [[[1,1,1,1]], [[1],[1],[1],[1]]],
            [[[1,1],[1,1]]],
            [[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]],
            [[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]],
            [[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]],
            [[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]],
            [[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]]
        ];
        const COLORS = {
            1: 0x00F0F0, 2: 0xF0F000, 3: 0xA000F0, 4: 0x00F000, 5: 0xF00000, 6: 0x0000F0, 7: 0xF0A000,
        };

        let moveSound, rotateSound, gameOverSound, bgmLoop, lineClearSound, ttsAudio;
        let audioUnlocked = false;
        let isMusicMuted = false; // Track mute state
        let blueGridMat, greenGridMat;

        function triggerHaptic(duration = 20) {
            if (navigator.vibrate) navigator.vibrate(duration);
        }
        
        init();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(0, 10, 0);
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            customArButton = document.getElementById('custom-ar-button');
            messageBox = document.getElementById('message-box');
            scoreBox = document.getElementById('score-box');
            levelBox = document.getElementById('level-box');
            gameOverBox = document.getElementById('game-over-box');
            geminiTipButton = document.getElementById('gemini-tip-button');
            replayButton = document.getElementById('replay-button');
            ttsAudio = document.getElementById('audio-tts');
            
            // --- NEW: Music Toggle Setup ---
            musicToggleBtn = document.getElementById('music-toggle');
            iconSoundOn = document.getElementById('icon-sound-on');
            iconSoundOff = document.getElementById('icon-sound-off');

            // Initialize audio variables
            bgmLoop = document.getElementById('audio-bgm');
            moveSound = document.getElementById('audio-move');
            rotateSound = document.getElementById('audio-move'); 
            gameOverSound = document.getElementById('audio-gameover');
            lineClearSound = document.getElementById('audio-lineclear');

            const arButton = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test'], 
                optionalFeatures: ['dom-overlay', 'local-floor'], 
                domOverlay: { root: document.body }
            });
            arButton.id = "default-ar-button"; 
            document.body.appendChild(arButton);

            customArButton.addEventListener('click', () => {
                initAudioAndUnlock();
                // Play music on start (if not muted)
                if (bgmLoop && !isMusicMuted) {
                    bgmLoop.play().catch(e => console.error("BGM play failed:", e));
                }
                arButton.click(); 
            });
            
            geminiTipButton.addEventListener('click', () => {
                geminiTipButton.disabled = true;
                geminiTipButton.textContent = "Processing...";
                getGeminiTip();
            });

            replayButton.addEventListener('click', () => {
                resetGame();
            });

            // --- NEW: Music Toggle Click Handler ---
            musicToggleBtn.addEventListener('click', () => {
                toggleMusic();
            });

            renderer.xr.addEventListener('sessionstart', () => {
                if (gameState === GAME_STATE.INITIALIZING) {
                    // Re-verify BGM is playing
                    if (bgmLoop && bgmLoop.paused && !isMusicMuted) {
                        bgmLoop.play().catch(e => console.error("BGM resume error:", e));
                    }
                    
                    customArButton.style.display = 'none';
                    gameState = GAME_STATE.SCANNING;
                    updateMessage("Scan floor to start");

                    const currentSession = renderer.xr.getSession();
                    currentSession.requestReferenceSpace('viewer').then((referenceSpace) => {
                        currentSession.requestHitTestSource({ 
                            space: referenceSpace 
                        }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                }
            });
            
            renderer.xr.addEventListener('sessionend', () => {
                if (bgmLoop) bgmLoop.pause();
                window.location.reload();
            });

            // Touch Controls
            let touchStartX, touchStartY, touchStartTime;
            let strafeInterval = null;
            let isDragging = false;
            const DRAG_THRESHOLD_Y = 75; 
            const STRAFE_INTERVAL_MS = 130; 

            function onTouchStart(e) {
                // Allow touches on buttons and music toggle
                if (e.target.tagName === 'BUTTON' || e.target.closest('#music-toggle')) return;

                e.preventDefault(); 
                if (gameState === GAME_STATE.PLACING) {
                    updateMessage("Starting Game...", true);
                    startGame();
                    return; 
                }
                if (gameState !== GAME_STATE.PLAYING || e.touches.length > 1) return; 

                if (strafeInterval) clearInterval(strafeInterval);
                const touch = e.touches[0];
                touchStartX = touch.pageX;
                touchStartY = touch.pageY;
                touchStartTime = new Date().getTime();
                isDragging = false;

                const screenWidth = window.innerWidth;
                if (touchStartX < screenWidth * 0.33) {
                    movePiece(-1); 
                    strafeInterval = setInterval(() => movePiece(-1), STRAFE_INTERVAL_MS);
                } else if (touchStartX > screenWidth * 0.66) {
                    movePiece(1); 
                    strafeInterval = setInterval(() => movePiece(1), STRAFE_INTERVAL_MS);
                }
            }
            
            function onTouchMove(e) {
                if (e.target.tagName === 'BUTTON' || e.target.closest('#music-toggle')) return;
                e.preventDefault();
                if (gameState !== GAME_STATE.PLAYING || !touchStartY || e.touches.length > 1) return;
                
                const touch = e.touches[0];
                const deltaY = touch.pageY - touchStartY;
                
                if (deltaY > DRAG_THRESHOLD_Y) {
                    if (strafeInterval) clearInterval(strafeInterval); 
                    hardDrop();
                    touchStartY = null; 
                    touchStartX = null;
                    isDragging = true; 
                }
            }
            
            function onTouchEnd(e) {
                if (e.target.tagName === 'BUTTON' || e.target.closest('#music-toggle')) return;
                e.preventDefault();
                if (gameState !== GAME_STATE.PLAYING) return;
                if (strafeInterval) clearInterval(strafeInterval);
                if (isDragging) { isDragging = false; return; }
                
                const screenWidth = window.innerWidth;
                const touchTime = new Date().getTime() - touchStartTime;

                if (touchTime < STRAFE_INTERVAL_MS * 1.5) { 
                    if (touchStartX > screenWidth * 0.33 && touchStartX < screenWidth * 0.66) {
                        rotatePiece();
                    }
                }
            }
            
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
            renderer.domElement.addEventListener('touchcancel', onTouchEnd, { passive: false });

            window.addEventListener('resize', onWindowResize);
            
            // Materials
            blueGridMat = new THREE.MeshBasicMaterial({ color: 0x00FFFF, wireframe: true, transparent: true, opacity: 0.7 });
            greenGridMat = new THREE.MeshBasicMaterial({ color: 0x00FF00, wireframe: true, transparent: true, opacity: 0.8 });

            // Scanner Mesh
            const gridGeo = new THREE.PlaneGeometry(BOARD_WIDTH * BLOCK_SIZE, BOARD_WIDTH * BLOCK_SIZE, BOARD_WIDTH, BOARD_WIDTH);
            placementGrid = new THREE.Mesh(gridGeo, blueGridMat);
            placementGrid.visible = false;
            
            // Rotate the geometry so it lies flat on the XZ plane by default
            gridGeo.rotateX(-Math.PI / 2);

            scene.add(placementGrid);
            
            gameBoard = new THREE.Group();
            renderer.setAnimationLoop(animate);
        }

        // --- NEW: Toggle Music Function ---
        function toggleMusic() {
            if (!bgmLoop) return;

            if (isMusicMuted) {
                // Unmute
                bgmLoop.play().catch(e => console.error("BGM play failed:", e));
                iconSoundOn.style.display = 'block';
                iconSoundOff.style.display = 'none';
                isMusicMuted = false;
            } else {
                // Mute
                bgmLoop.pause();
                iconSoundOn.style.display = 'none';
                iconSoundOff.style.display = 'block';
                isMusicMuted = true;
            }
        }

        function initAudioAndUnlock() {
            if (audioUnlocked) return; 
            
            bgmLoop = document.getElementById('audio-bgm');
            moveSound = document.getElementById('audio-move');
            rotateSound = document.getElementById('audio-move'); 
            gameOverSound = document.getElementById('audio-gameover');
            lineClearSound = document.getElementById('audio-lineclear');
            
            const sounds = [bgmLoop, moveSound, rotateSound, gameOverSound, lineClearSound, ttsAudio];
            
            sounds.forEach(sound => {
                if (sound) {
                    sound.load(); 
                    const playPromise = sound.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            if (sound !== bgmLoop) {
                                sound.pause();
                                sound.currentTime = 0;
                            }
                        }).catch(e => { console.warn("Audio unlock warning:", e); });
                    }
                }
            });

            bgmLoop.volume = 0.3;
            moveSound.volume = 0.8;
            rotateSound.volume = 0.8;
            gameOverSound.volume = 0.7;
            if(lineClearSound) lineClearSound.volume = 0.7;
            ttsAudio.volume = 1.0;
            
            audioUnlocked = true;
        }

        function playSound(audioElement) {
            if (!audioElement || !audioUnlocked) return;
            audioElement.currentTime = 0; 
            audioElement.play().catch(e => console.warn("Sound play warning:", e)); 
        }

        function animate(timestamp, frame) {
            if (frame) {
                const session = renderer.xr.getSession();
                if (!session) {
                    renderer.render(scene, camera);
                    return;
                }

                if (gameState === GAME_STATE.SCANNING || gameState === GAME_STATE.PLACING) {
                    if (hitTestSource) {
                        const hitTestResults = frame.getHitTestResults(hitTestSource); 

                        if (hitTestResults.length > 0) {
                            const hit = hitTestResults[0];
                            const referenceSpace = renderer.xr.getReferenceSpace();
                            const pose = hit.getPose(referenceSpace);
                            
                            placementGrid.matrix.fromArray(pose.transform.matrix);
                            placementGrid.matrixAutoUpdate = false; 
                            placementGrid.visible = true; 

                            const normalY = pose.transform.matrix[5]; 
                            const isFloor = normalY > 0.85;

                            if (isFloor) {
                                if (gameState === GAME_STATE.SCANNING) {
                                    gameState = GAME_STATE.PLACING;
                                    updateMessage("Tap to lock");
                                    placementGrid.material = greenGridMat; 
                                    triggerHaptic(50); 
                                }
                            } else {
                                if (gameState === GAME_STATE.PLACING) {
                                    gameState = GAME_STATE.SCANNING;
                                    updateMessage("Scan floor to start");
                                }
                                placementGrid.material = blueGridMat; 
                            }
                        } else {
                            placementGrid.visible = false; 
                            if (gameState === GAME_STATE.PLACING) {
                                gameState = GAME_STATE.SCANNING;
                                updateMessage("Scan floor to start");
                            }
                        }
                    }
                }
            }
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateMessage(message, autoHide = false) {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            if (autoHide) {
                setTimeout(() => { messageBox.style.display = 'none'; }, 2000);
            }
        }

        function startGame() {
            gameState = GAME_STATE.PLAYING;
            scoreBox.style.display = 'block';
            levelBox.style.display = 'block'; 
            updateScore(0);
            
            const depthOffset = -0.5; 
            const baseLift = (BOARD_HEIGHT / 2) * BLOCK_SIZE; 

            const



<!DOCTYPE html>
<html lang="en">

<head>
    <title>AR Tetris 3D (Quest Ready)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="xr-spatial-tracking" content="true">
    
    <!-- Load Google Font: Montserrat (Medium & Bold) -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;800&display=swap" rel="stylesheet">
    <!-- Load Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">

    <style>
        /* --- Load Custom Font --- */
        @font-face {
            font-family: 'TetrisBlocks';
            src: url('font/TetrisBlocks-P99g.ttf') format('truetype');
        }

        /* Basic reset */
        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Montserrat', sans-serif; 
            font-weight: 400; 
            background-color: #111;
            color: white;
            touch-action: none; 
        }

        /* The 3D canvas */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #default-ar-button {
            display: none !important;
            visibility: hidden !important;
        }

        /* --- Shared Glassmorphism Style --- */
        .glass-panel {
            background: rgba(20, 20, 20, 0.8); 
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            color: white;
            pointer-events: none; 
        }

        /* Unified HUD (Top Left) */
        #hud-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 100;
            min-width: 100px;
            opacity: 0; 
            transition: opacity 0.3s ease;
        }
        
        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .hud-label {
            color: #aaa;
            font-weight: 400;
            margin-right: 10px;
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        .hud-value {
            color: #FFDC00; 
            font-family: 'Montserrat', monospace; 
        }
        
        #level-value {
            color: #00FFFF; 
        }

        /* Feedback (Recording) */
        #recording-panel {
            position: absolute;
            top: 100px; 
            left: 20px;
            display: none; 
            flex-direction: row;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 20px;
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            z-index: 100;
        }
        
        #recording-dot {
            width: 8px;
            height: 8px;
            background-color: #FF4136;
            border-radius: 50%;
            animation: blink-red 1s infinite;
        }
        
        #recording-timer {
            font-size: 0.8rem;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: #FF4136;
        }

        @keyframes blink-red {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        /* Consistent Iconography (Top Right Controls) */
        .control-btn {
            position: absolute;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 102;
            pointer-events: auto;
            transition: transform 0.1s, background-color 0.2s;
            /* Glass style default */
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }
        
        .control-btn .material-icons-round {
            font-size: 24px;
        }

        #music-toggle {
            top: 20px;
            right: 20px;
        }

        #record-button {
            top: 74px; /* Below music toggle */
            right: 20px;
            /* Default is Grey/White Translucent */
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        /* Active Recording is Red */
        #record-button.recording {
            background: rgba(255, 0, 0, 0.9); 
            border-color: #FF4136;
            animation: pulse-record 2s infinite;
        }
        
        @keyframes pulse-record {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }
        
        #record-button .material-icons-round {
            color: white;
        }

        /* Onboarding & Instruction */
        #message-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            padding: 12px 24px;
            text-align: center;
            display: none; 
            align-items: center;
            gap: 10px;
            font-weight: 600;
            pointer-events: none;
            white-space: nowrap;
        }
        
        @keyframes sway {
            0% { transform: rotate(-10deg); }
            100% { transform: rotate(10deg); }
        }
        
        .phone-icon {
            font-size: 20px;
            animation: sway 1s ease-in-out infinite alternate;
            display: none; 
        }

        /* Launch Button */
        @keyframes btn-pulse {
            0% { box-shadow: 0 0 0 0 rgba(138, 43, 226, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(138, 43, 226, 0); }
            100% { box-shadow: 0 0 0 0 rgba(138, 43, 226, 0); }
        }

        #custom-ar-button {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            padding: 16px 32px;
            border-radius: 50px;
            background: linear-gradient(135deg, #8a2be2, #4169e1);
            color: white;
            font-family: 'Montserrat', sans-serif;
            font-size: 1.1rem; 
            font-weight: 700;
            border: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            z-index: 101;
            transition: transform 0.2s;
            pointer-events: auto; 
            text-transform: uppercase;
            letter-spacing: 1px;
            animation: btn-pulse 2s infinite;
        }

        #custom-ar-button:active {
            transform: translateX(-50%) scale(0.95);
        }

        /* --- Device Note Above Button --- */
        #device-note {
            position: absolute;
            /* RETAIN: Positioning relative to bottom */
            bottom: 150px; 
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            /* RETAIN: Smaller font size */
            font-size: 0.55rem;
            font-family: 'Montserrat', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            pointer-events: none;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            z-index: 101;
            white-space: nowrap;
            /* RETAIN: Flex container to allow line break */
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.2;
        }
        /* MODIFIED: Increased margin-top for better separation */
        #device-note span {
            display: block;
            margin-top: 2px; 
        }


        /* Game Over Modal */
        #game-over-card {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 300px;
            padding: 30px 20px;
            display: none; 
            flex-direction: column;
            align-items: center;
            gap: 20px;
            z-index: 105;
            text-align: center;
            pointer-events: auto;
        }
        
        .go-title {
            font-size: 2rem;
            font-weight: 800;
            color: #FF4136;
            text-transform: uppercase;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .go-stats {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100%;
        }
        
        .go-stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 5px;
        }
        
        .go-label { color: #aaa; }
        .go-val { font-weight: 700; }

        #replay-button {
            padding: 12px 30px;
            border-radius: 25px;
            background: linear-gradient(135deg, #2ecc71, #27ae60); 
            color: white;
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem; 
            font-weight: 700;
            border: none;
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
            cursor: pointer;
            transition: transform 0.1s;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 100%;
        }

        #replay-button:active {
            transform: scale(0.95);
        }
        
        /* Intro Screen Styles */
        #intro-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.85); 
            backdrop-filter: blur(5px);
            z-index: 200; 
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        
        #intro-title {
            font-family: 'Montserrat', sans-serif; 
            font-weight: 900; 
            font-size: 3rem; 
            color: #FF00FF; 
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
            margin-bottom: 5px;
            text-align: center;
            letter-spacing: -1px;
            line-height: 1;
        }
        
        #intro-subtitle {
            font-family: 'Montserrat', sans-serif; 
            font-weight: 300;
            font-size: 1.2rem; 
            color: #00FFFF; 
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            letter-spacing: 6px;
            text-transform: uppercase;
        }

    </style>
</head>

<body>
    <!-- 1. Unified HUD -->
    <div id="hud-panel" class="glass-panel">
        <div class="hud-row">
            <span class="hud-label">Score</span>
            <span class="hud-value" id="score-val">0</span>
        </div>
        <div class="hud-row">
            <span class="hud-label">Level</span>
            <span class="hud-value" id="level-val">1</span>
        </div>
    </div>

    <!-- 2. Feedback (Recording Timer) -->
    <div id="recording-panel">
        <div id="recording-dot"></div>
        <div id="recording-timer" id="rec-time">00:00</div>
    </div>

    <!-- 5. Onboarding Message -->
    <div id="message-box" class="glass-panel">
        <span class="material-icons-round phone-icon">smartphone</span>
        <span id="message-text">Scan floor to start</span>
    </div>

    <!-- 6. Game Over Modal -->
    <div id="game-over-card" class="glass-panel">
        <h1 class="go-title">Game Over</h1>
        <div class="go-stats">
            <div class="go-stat-row">
                <span class="go-label">Score</span>
                <span class="go-val" id="go-score">0</span>
            </div>
            <div class="go-stat-row">
                <span class="go-label">Level</span>
                <span class="go-val" id="go-level">1</span>
            </div>
        </div>
        <button id="replay-button">
            <span class="material-icons-round" style="vertical-align: middle; margin-right: 5px; font-size: 1.2rem;">replay</span>
            Play Again
        </button>
    </div>

    <!-- Intro Screen -->
    <div id="intro-screen">
        <div id="intro-title">ROCKIN'<br>TETRIS</div>
        <div id="intro-subtitle">in AR</div>
    </div>

    <!-- 3. Consistent Icons -->
    <!-- Music Toggle -->
    <button id="music-toggle" class="control-btn" aria-label="Toggle Music">
        <span class="material-icons-round" id="icon-music">volume_up</span>
    </button>

    <!-- Recording Button -->
    <button id="record-button" class="control-btn" aria-label="Record Video">
        <span class="material-icons-round" id="icon-record-btn">fiber_manual_record</span>
    </button>

    <!-- Device Note & Main Launch Button -->
    <div id="device-note">Mobile and Meta Quest<span>only</span></div>
    <button id="custom-ar-button">
        LAUNCH AR/VR
    </button>
    
    <!-- Audio -->
    <audio id="audio-tts" preload="auto" playsinline></audio>
    
    <!-- RE-INTRODUCED PLACEHOLDER AUDIO ELEMENT -->
    <audio id="audio-bgm" src="music/music.mp3" loop preload="auto" playsinline></audio>
    <audio id="audio-move" src="music/tik.mp3" preload="auto" playsinline></audio>
    <audio id="audio-gameover" src="music/outro.mp3" preload="auto" playsinline></audio>
    <audio id="audio-lineclear" src="music/lineclear.mp3" preload="auto" playsinline></audio>
    <!-- TOOT Sound -->
    <audio id="audio-toot" src="data:audio/wav;base64,UklGRl9vT1ZYXxcqU1qa..." preload="auto" playsinline></audio>

    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        
        // --- Global Variables ---
        let camera, scene, renderer;
        let controller1, controller2; // VR Controllers
        let hitTestSource = null;
        let placementGrid = null; 
        let gameBoard = null; 
        let currentPiece = null;
        let gameLoopInterval = null;
        
        // UI Vars
        let customArButton, messageBox, messageText, phoneIcon, deviceNote;
        let hudPanel, scoreVal, levelVal;
        let gameOverCard, goScore, goLevel, replayButton;
        let musicToggleBtn, musicIcon;
        // FIXED: Globally declare record vars
        let recordButton, iconRecord, recordingIndicator;
        let recordingPanel, recTimer;
        
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let recStartTime;
        let recInterval;
        
        let introScreen;
        
        const GAME_STATE = {
            INITIALIZING: 0,
            SCANNING: 1,
            PLACING: 2,
            PLAYING: 3,
            GAME_OVER: 4,
            PAUSED: 5 // Added for animation
        };
        let gameState = GAME_STATE.INITIALIZING;
        let score = 0;
        
        // --- Level Variables ---
        let level = 1;
        let linesClearedTotal = 0;
        let currentDropSpeed = 1000; 
        const MIN_DROP_SPEED = 100; 

        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20; 
        const BLOCK_SIZE = 0.1; 
        
        let grid = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
        
        const SHAPES = [
            [[[1,1,1,1]], [[1],[1],[1],[1]]],
            [[[1,1],[1,1]]],
            [[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]],
            [[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]],
            [[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]],
            [[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]],
            [[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]]
        ];
        const COLORS = {
            1: 0x00F0F0, 2: 0xF0F000, 3: 0xA000F0, 4: 0x00F000, 5: 0xF00000, 6: 0x0000F0, 7: 0xF0A000,
        };

        let moveSound, gameOverSound, lineClearSound;
        let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let audioUnlocked = false;
        let isMusicMuted = false; 
        let blueGridMat, greenGridMat;
        
        // BGM Specific HTML Audio Element
        let bgmElement; 

        // Controller Logic Variables
        const controllerData = {
            left: { axisX: 0, axisY: 0, isSelecting: false, isSqueezing: false },
            right: { axisX: 0, axisY: 0, isSelecting: false, isSqueezing: false }
        };
        // Debounce/Cooldowns for joystick movement
        let lastMoveTime = 0;
        let lastRotateTime = 0;
        const JOYSTICK_MOVE_DELAY = 150; // ms between moves when holding stick
        const JOYSTICK_ROTATE_DELAY = 250; 
        const JOYSTICK_DEADZONE = 0.3;

        function triggerHaptic(duration = 20) {
            // Mobile Haptic
            if (navigator.vibrate) navigator.vibrate(duration);
            
            // XR Controller Haptic
            const session = renderer.xr.getSession();
            if (session) {
                for (const source of session.inputSources) {
                    if (source.gamepad && source.gamepad.hapticActuators && source.gamepad.hapticActuators[0]) {
                        source.gamepad.hapticActuators[0].pulse(1.0, duration);
                    }
                }
            }
        }

        // --- BGM HTML Audio Control ---
        function startBGM() {
            if (bgmElement) {
                bgmElement.volume = 0.05; // Low gain (5%)
                if (bgmElement.paused) {
                    bgmElement.play().catch(e => console.warn("BGM play failed (placeholder link)", e));
                }
            }
        }

        function stopBGM() {
            if (bgmElement) {
                bgmElement.pause();
                bgmElement.currentTime = 0;
            }
        }

        // --- SYNTHESIZED "AIRY WOOF" SOUND ---
        function playRotateSound() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            // 1. "Smooth/Airy" Waveform
            osc.type = 'sine'; 
            
            // 2. Frequency: Lowered by 30% (approx 150Hz starting, dropping to 100Hz)
            // This creates the "Woof" body
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);

            // 3. Filter: Low-pass to make it muffled/airy, removing harsh highs
            filter.type = 'lowpass';
            filter.frequency.value = 400;

            // 4. Volume: Lowered and Smooth Envelope
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.02); // Soft attack (no click)
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15); // Quick decay

            // Connect graph
            osc.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        }

        function playToot() {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, audioCtx.currentTime); 
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); 
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }
        
        init();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(0, 10, 0);
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // --- XR CONTROLLER SETUP ---
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('select', onControllerSelect);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('select', onControllerSelect);
            scene.add(controller2);

            // Bind UI Elements
            customArButton = document.getElementById('custom-ar-button');
            deviceNote = document.getElementById('device-note');
            
            messageBox = document.getElementById('message-box');
            messageText = document.getElementById('message-text');
            phoneIcon = document.querySelector('.phone-icon');
            
            hudPanel = document.getElementById('hud-panel');
            scoreVal = document.getElementById('score-val');
            levelVal = document.getElementById('level-val');
            
            gameOverCard = document.getElementById('game-over-card');
            goScore = document.getElementById('go-score');
            goLevel = document.getElementById('go-level');
            replayButton = document.getElementById('replay-button');
            
            introScreen = document.getElementById('intro-screen');
            
            musicToggleBtn = document.getElementById('music-toggle');
            musicIcon = document.getElementById('icon-music');
            
            // --- FIX: Record button elements defined inside init ---
            recordButton = document.getElementById('record-button');
            iconRecord = document.getElementById('icon-record-btn'); // Uses material icons now
            recordingPanel = document.getElementById('recording-panel');
            recTimer = document.getElementById('rec-time');

            // --- BGM Element Binding ---
            bgmElement = document.getElementById('audio-bgm');
            
            moveSound = document.getElementById('audio-move');
            gameOverSound = document.getElementById('audio-gameover');
            lineClearSound = document.getElementById('audio-lineclear');

            const arButton = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test'], 
                optionalFeatures: ['dom-overlay', 'local-floor'], 
                domOverlay: { root: document.body }
            });
            arButton.id = "default-ar-button"; 
            document.body.appendChild(arButton);

            // --- STRICT AUDIO UNLOCK ON CLICK ---
            customArButton.addEventListener('click', () => {
                console.log("Unlocking audio context...");
                if(audioCtx.state === 'suspended') audioCtx.resume();
                triggerHaptic(5); 
                
                const allSounds = [bgmElement, gameOverSound, lineClearSound];
                
                allSounds.forEach(s => {
                    if(s) {
                        const p = s.play();
                        if (p !== undefined) {
                            p.then(() => {
                                // If BGM loaded, set low volume
                                if (s === bgmElement) {
                                    s.volume = 0.05; // Set low gain
                                } else {
                                    s.pause();
                                    s.currentTime = 0;
                                }
                            }).catch(e => console.warn("Audio play failed (user must interact first)", e));
                        }
                    }
                });
                
                audioUnlocked = true;
                arButton.click(); 
            });
            
            replayButton.addEventListener('click', () => {
                triggerHaptic(5); 
                resetGame();
            });

            musicToggleBtn.addEventListener('click', () => {
                triggerHaptic(5); 
                toggleMusic();
            });

            // --- RECORDING LOGIC ---
            recordButton.addEventListener('click', () => {
                triggerHaptic(20);
                playToot(); 
                if (!isRecording) {
                    startRecording();
                } else {
                    stopRecording();
                }
            });

            renderer.xr.addEventListener('sessionstart', () => {
                if (gameState === GAME_STATE.INITIALIZING) {
                    // Volume Settings
                    if (moveSound) moveSound.volume = 0.08; 
                    if (lineClearSound) lineClearSound.volume = 0.08; 
                    if (gameOverSound) gameOverSound.volume = 0.08; 

                    if (!isMusicMuted) {
                        startBGM(); // Use HTML audio element
                    }
                    
                    customArButton.style.display = 'none';
                    deviceNote.style.display = 'none'; // Hide the note when in AR
                    // Show Controls
                    recordButton.style.display = 'flex';
                    
                    gameState = GAME_STATE.SCANNING;
                    updateMessage("Scan floor to start", true); // Show icon

                    const currentSession = renderer.xr.getSession();
                    currentSession.requestReferenceSpace('viewer').then((referenceSpace) => {
                        currentSession.requestHitTestSource({ 
                            space: referenceSpace 
                        }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                }
            });
            
            renderer.xr.addEventListener('sessionend', () => {
                stopBGM();
                if (isRecording) stopRecording();
                recordButton.style.display = 'none';
                window.location.reload();
            });

            // Touch Controls (Mobile fallback)
            let touchStartX, touchStartY, touchStartTime;
            let strafeInterval = null;
            let isDragging = false;
            const DRAG_THRESHOLD_Y = 75; 
            const STRAFE_INTERVAL_MS = 130; 
            const SCREEN_THIRD = window.innerWidth / 3;

            function onTouchStart(e) {
                // Prevent interfering with buttons
                if (e.target.tagName === 'BUTTON' || e.target.closest('.control-btn') || e.target.closest('#replay-button')) return;

                e.preventDefault(); 
                
                if (gameState === GAME_STATE.PLACING) {
                    updateMessage("", false); 
                    playIntroAndStart(); 
                    return; 
                }
                
                if (gameState !== GAME_STATE.PLAYING || e.touches.length > 1) return; 

                if (strafeInterval) clearInterval(strafeInterval);
                const touch = e.touches[0];
                touchStartX = touch.pageX;
                touchStartY = touch.pageY;
                touchStartTime = new Date().getTime();
                isDragging = false;
                
                // Start continuous strafing if touch is held on sides
                if (touchStartX < SCREEN_THIRD) {
                    movePiece(-1); 
                    strafeInterval = setInterval(() => movePiece(-1), STRAFE_INTERVAL_MS);
                } else if (touchStartX > SCREEN_THIRD * 2) {
                    movePiece(1); 
                    strafeInterval = setInterval(() => movePiece(1), STRAFE_INTERVAL_MS);
                }
            }
            
            function onTouchMove(e) {
                if (e.target.tagName === 'BUTTON' || e.target.closest('.control-btn')) return;
                e.preventDefault();
                if (gameState !== GAME_STATE.PLAYING || !touchStartY || e.touches.length > 1) return;
                
                const touch = e.touches[0];
                const deltaY = touch.pageY - touchStartY;
                
                if (deltaY > DRAG_THRESHOLD_Y && !isDragging) {
                    // Vertical drag for hard drop
                    if (strafeInterval) clearInterval(strafeInterval); 
                    hardDrop();
                    touchStartY = null; 
                    touchStartX = null;
                    isDragging = true; 
                }
            }
            
            function onTouchEnd(e) {
                if (e.target.tagName === 'BUTTON' || e.target.closest('.control-btn')) return;
                e.preventDefault();
                if (gameState !== GAME_STATE.PLAYING) return;
                if (strafeInterval) clearInterval(strafeInterval);
                
                // If this was a drag (hard drop), ignore as a tap
                if (isDragging) { isDragging = false; return; }
                
                const touchTime = new Date().getTime() - touchStartTime;

                // Check if it was a quick middle tap for rotation
                if (touchTime < 250) { // Short tap threshold
                    if (touchStartX > SCREEN_THIRD && touchStartX < SCREEN_THIRD * 2) {
                        rotatePiece();
                    }
                }
            }
            
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
            renderer.domElement.addEventListener('touchcancel', onTouchEnd, { passive: false });

            window.addEventListener('resize', onWindowResize);
            
            blueGridMat = new THREE.MeshBasicMaterial({ color: 0x00FFFF, wireframe: true, transparent: true, opacity: 0.7 });
            greenGridMat = new THREE.MeshBasicMaterial({ color: 0x00FF00, wireframe: true, transparent: true, opacity: 0.8 });

            const gridGeo = new THREE.PlaneGeometry(BOARD_WIDTH * BLOCK_SIZE, BOARD_WIDTH * BLOCK_SIZE, BOARD_WIDTH, BOARD_WIDTH);
            placementGrid = new THREE.Mesh(gridGeo, blueGridMat);
            placementGrid.visible = false;
            gridGeo.rotateX(-Math.PI / 2);

            scene.add(placementGrid);
            
            gameBoard = new THREE.Group();
            renderer.setAnimationLoop(animate);
        }
        
        // --- XR CONTROLLER EVENT HANDLER ---
        function onControllerSelect() {
            // This handles the "Click" logic for the controllers
            if (gameState === GAME_STATE.PLACING) {
                updateMessage("", false); 
                playIntroAndStart(); 
            } else if (gameState === GAME_STATE.PLAYING) {
                rotatePiece(); // Trigger rotates in game
            }
        }

        // --- XR INPUT POLLING (JOYSTICKS) ---
        function pollControllers() {
            const session = renderer.xr.getSession();
            if (!session) return;

            const now = Date.now();

            for (const source of session.inputSources) {
                if (source.gamepad) {
                    const gamepad = source.gamepad;
                    
                    // Standard WebXR Gamepad Mapping
                    // axes[2] = Thumbstick X, axes[3] = Thumbstick Y
                    // buttons[0] = Trigger, buttons[1] = Squeeze, buttons[4] or 5 = A/X
                    
                    // Fallback to 0/1 if 2/3 empty (some browsers/profiles differ)
                    let axisX = gamepad.axes[2] || gamepad.axes[0] || 0;
                    let axisY = gamepad.axes[3] || gamepad.axes[1] || 0;

                    // MOVEMENT LEFT/RIGHT
                    if (Math.abs(axisX) > JOYSTICK_DEADZONE) {
                        if (now - lastMoveTime > JOYSTICK_MOVE_DELAY) {
                            if (axisX < -JOYSTICK_DEADZONE) movePiece(-1);
                            if (axisX > JOYSTICK_DEADZONE) movePiece(1);
                            lastMoveTime = now;
                        }
                    }

                    // ROTATE (Stick Up) or DROP (Stick Down)
                    if (Math.abs(axisY) > JOYSTICK_DEADZONE) {
                         if (now - lastMoveTime > JOYSTICK_MOVE_DELAY) {
                            if (axisY > JOYSTICK_DEADZONE) {
                                // Stick Down -> Soft Drop
                                if (isValidMove(currentPiece, { y: 1 })) {
                                    currentPiece.userData.gridPos.y += 1;
                                    updatePiecePosition(currentPiece);
                                    score += 1; // small bonus
                                    scoreVal.textContent = score;
                                }
                            } else if (axisY < -JOYSTICK_DEADZONE) {
                                // Stick Up -> Rotate
                                if (now - lastRotateTime > JOYSTICK_ROTATE_DELAY) {
                                    rotatePiece();
                                    lastRotateTime = now;
                                }
                            }
                            lastMoveTime = now;
                         }
                    }

                    // SQUEEZE (Button index 1) -> Hard Drop
                    if (gamepad.buttons[1] && gamepad.buttons[1].pressed) {
                        // Debounce squeeze slightly via lastMoveTime
                         if (now - lastMoveTime > 500) { 
                             hardDrop();
                             lastMoveTime = now;
                         }
                    }
                }
            }
        }

        function startRecording() {
            const stream = renderer.domElement.captureStream(30); 
            const mimeType = MediaRecorder.isTypeSupported('video/mp4') ? 'video/mp4' : 'video/webm';
            
            try {
                mediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });
            } catch (e) {
                console.error("MediaRecorder setup failed:", e);
                // updateMessage("Recording not supported"); // Dont show msg in HUD
                return;
            }

            recordedChunks = [];
            mediaRecorder.ondataavailable = (event) => { if (event.data.size > 0) recordedChunks.push(event.data); };
            mediaRecorder.onstop = saveAndShareVideo;
            mediaRecorder.start();
            isRecording = true;
            
            recordButton.classList.add('recording');
            iconRecord.textContent = "stop"; // Change material icon text to stop
            recordingPanel.style.display = 'flex';
            
            // Start timer
            recStartTime = Date.now();
            recInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - recStartTime) / 1000);
                const m = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const s = (elapsed % 60).toString().padStart(2, '0');
                recTimer.textContent = `${m}:${s}`;
            }, 1000);
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                clearInterval(recInterval);
                
                recordButton.classList.remove('recording');
                iconRecord.textContent = "fiber_manual_record"; // Change material icon text back
                recordingPanel.style.display = 'none';
                recTimer.textContent = "00:00";
                
                updateMessage("Processing video...");
            }
        }

        function saveAndShareVideo() {
            const blob = new Blob(recordedChunks, { type: 'video/mp4' }); 
            const file = new File([blob], "ar-tetris-gameplay.mp4", { type: 'video/mp4' });

            if (navigator.canShare && navigator.canShare({ files: [file] })) {
                navigator.share({
                    title: 'My AR Tetris Gameplay!',
                    text: 'Check out this cool AR Tetris game!',
                    files: [file]
                })
                .then(() => { updateMessage("Shared!", true); })
                .catch((error) => { downloadVideo(blob); });
            } else {
                downloadVideo(blob);
            }
        }

        function downloadVideo(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            document.body.appendChild(a);
            a.style = 'display: none';
            a.href = url;
            a.download = 'ar-tetris-gameplay.mp4';
            a.click();
            window.URL.revokeObjectURL(url);
            updateMessage("Video downloaded!", true);
        }

        function toggleMusic() {
            if (!bgmElement) return;

            if (isMusicMuted) {
                // Unmute/start BGM
                startBGM();
                musicIcon.textContent = "volume_up";
                isMusicMuted = false;
            } else {
                // Mute/stop BGM
                stopBGM();
                musicIcon.textContent = "volume_off";
                isMusicMuted = true;
            }
        }

        function playSound(audioElement) {
            if (!audioElement) return;
            audioElement.currentTime = 0; 
            audioElement.play().catch(e => console.warn("Sound play warning:", e)); 
        }

        function animate(timestamp, frame) {
            if (frame) {
                const session = renderer.xr.getSession();
                
                // --- UPDATE VR CONTROLS ---
                if (gameState === GAME_STATE.PLAYING) {
                    pollControllers();
                }

                if (!session) {
                    renderer.render(scene, camera);
                    return;
                }

                if (gameState === GAME_STATE.SCANNING || gameState === GAME_STATE.PLACING) {
                    if (hitTestSource) {
                        const hitTestResults = frame.getHitTestResults(hitTestSource); 

                        if (hitTestResults.length > 0) {
                            const hit = hitTestResults[0];
                            const referenceSpace = renderer.xr.getReferenceSpace();
                            const pose = hit.getPose(referenceSpace);
                            
                            placementGrid.matrix.fromArray(pose.transform.matrix);
                            placementGrid.matrixAutoUpdate = false; 
                            placementGrid.visible = true; 

                            const normalY = pose.transform.matrix[5]; 
                            const isFloor = normalY > 0.85;

                            if (isFloor) {
                                if (gameState === GAME_STATE.SCANNING) {
                                    gameState = GAME_STATE.PLACING;
                                    updateMessage("Tap or Trigger to lock", false);
                                    placementGrid.material = greenGridMat; 
                                    triggerHaptic(50); 
                                }
                            } else {
                                if (gameState === GAME_STATE.PLACING) {
                                    gameState = GAME_STATE.SCANNING;
                                    updateMessage("Scan floor to start", true);
                                    placementGrid.material = blueGridMat; 
                                }
                            }
                        } else {
                            placementGrid.visible = false; 
                            if (gameState === GAME_STATE.PLACING) {
                                gameState = GAME_STATE.SCANNING;
                                updateMessage("Scan floor to start", true);
                            }
                        }
                    }
                } else {
                    // Force hide mesh when PLAYING or GAME_OVER
                    placementGrid.visible = false;
                }
            }
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateMessage(message, showIcon = false) {
            messageText.textContent = message;
            messageBox.style.display = message ? 'flex' : 'none';
            phoneIcon.style.display = showIcon ? 'block' : 'none';
        }

        function playIntroAndStart() {
            const depthOffset = -0.5; 
            const baseLift = (BOARD_HEIGHT / 2) * BLOCK_SIZE; 

            const targetPos = new THREE.Vector3();
            targetPos.setFromMatrixPosition(placementGrid.matrix);
            gameBoard.position.copy(targetPos);
            
            const cameraPos = new THREE.Vector3();
            camera.getWorldPosition(cameraPos);
            gameBoard.lookAt(cameraPos.x, gameBoard.position.y, cameraPos.z);
            
            // Treat floor as a bit lower (-0.15m)
            gameBoard.translateY(baseLift - 0.15); 
            gameBoard.translateZ(depthOffset);
            
            scene.add(gameBoard);
            placementGrid.visible = false; 
            
            introScreen.style.display = 'flex';
            
            setTimeout(() => {
                introScreen.style.opacity = '1';
            }, 50); 

            setTimeout(() => {
                introScreen.style.opacity = '0';
                
                setTimeout(() => {
                    introScreen.style.display = 'none';
                    startGame();
                }, 500); 
                
            }, 2500); 
        }

        function startGame() {
            gameState = GAME_STATE.PLAYING;
            hudPanel.style.opacity = '1'; // Show HUD
            updateScore(0);
            
            placementGrid.visible = false;

            spawnPiece();
            
            gameLoopInterval = setInterval(gameTick, currentDropSpeed);
        }

        function gameTick() {
            // FIXED: STRICT CHECK TO STOP TICK IF GAME OVER
            if (gameState !== GAME_STATE.PLAYING) return;

            if (!currentPiece) return;
            if (isValidMove(currentPiece, { y: 1 })) {
                currentPiece.userData.gridPos.y += 1;
                updatePiecePosition(currentPiece);
            } else {
                lockPiece();
                spawnPiece();
            }
        }
        
        function gameOver() {
            clearInterval(gameLoopInterval);
            gameState = GAME_STATE.GAME_OVER;
            
            goScore.textContent = score;
            goLevel.textContent = level;
            gameOverCard.style.display = 'flex';

            // FIXED: Ensure the current piece is removed/nullified immediately upon Game Over logic starting
            if (currentPiece) {
                gameBoard.remove(currentPiece);
            }
            currentPiece = null; 
            
            stopBGM();
            playSound(gameOverSound);
        }

        // 7. Reset game: Go back to scanning
        function resetGame() {
            // FIXED: STOP OUTRO MUSIC IMMEDIATELY
            if (gameOverSound) {
                gameOverSound.pause();
                gameOverSound.currentTime = 0;
            }

            gameOverCard.style.display = 'none';
            
            for (let i = gameBoard.children.length - 1; i >= 0; i--) {
                const child = gameBoard.children[i];
                gameBoard.remove(child);
            }
            scene.remove(gameBoard); 
            gameBoard = new THREE.Group(); 

            grid = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
            score = 0;
            linesClearedTotal = 0;
            level = 1;
            currentDropSpeed = 1000;
            
            // Hide HUD
            hudPanel.style.opacity = '0';

            // Restart BGM if not muted
            if (!isMusicMuted) {
                startBGM();
            }

            // Reset to SCANNING state
            gameState = GAME_STATE.SCANNING;
            updateMessage("Scan floor to start", true);
            placementGrid.visible = false; 
        }

        function updateScore(linesCleared) {
            if (linesCleared > 0) {
                const points = { 1: 100, 2: 300, 3: 500, 4: 800 };
                score += points[linesCleared] || 0;
                
                linesClearedTotal += linesCleared;
                const newLevel = Math.floor(linesClearedTotal / 5) + 1; 
                
                if (newLevel > level) {
                    level = newLevel;
                    levelBox.textContent = `Level: ${level}`;
                    currentDropSpeed = Math.max(MIN_DROP_SPEED, currentDropSpeed * 0.9);
                    
                    clearInterval(gameLoopInterval);
                    gameLoopInterval = setInterval(gameTick, currentDropSpeed);
                }

                playSound(lineClearSound);
                const flash = document.createElement('div');
                flash.style.position = 'absolute';
                flash.style.top = '0';
                flash.style.left = '0';
                flash.style.width = '100%';
                flash.style.height = '100%';
                flash.style.backgroundColor = 'rgba(255, 255, 255, 0.7)';
                flash.style.zIndex = '999';
                flash.style.pointer-events = 'none'; 
                document.body.appendChild(flash);
                setTimeout(() => document.body.removeChild(flash), 100);
            }
            scoreVal.textContent = score;
            levelVal.textContent = level;
        }
        
        function checkLineClears() {
            let linesCleared = 0;
            let rowsToClear = [];
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                if (grid[y].every(cell => cell > 0)) {
                    linesCleared++;
                    rowsToClear.push(y);
                }
            }
            
            if (linesCleared > 0) {
                // 4. Slow Animation (Pause Game)
                clearInterval(gameLoopInterval);

                const blocksToAnimate = [];
                gameBoard.children.forEach(block => {
                    // Check if the block is one of the permanent, locked blocks (not the current falling piece)
                    if (block !== currentPiece) {
                        // Calculate grid Y position
                        const blockY = Math.round(BOARD_HEIGHT / 2 - 0.5 - (block.position.y / BLOCK_SIZE));
                        if (rowsToClear.includes(blockY)) {
                            blocksToAnimate.push(block);
                        }
                    }
                });

                let progress = 0;
                const duration = 1000; // MUST BE 1000ms (1 second)
                let lastTimestamp = performance.now(); // Use performance.now() for precise timing

                function animateClear(timestamp) {
                    // Use time elapsed since last frame instead of relying purely on frame count
                    const deltaTime = timestamp - lastTimestamp;
                    lastTimestamp = timestamp;

                    // Calculate progress based on time, clamping at 1.0 to ensure completion
                    progress = Math.min(1.0, progress + (deltaTime / duration));

                    if (progress < 1) {
                        blocksToAnimate.forEach(b => {
                            // Spin & Shrink (rotation speed adjusted to complete in 1 second)
                            const rotationFactor = 0.01; // Base rotation factor
                            b.scale.setScalar(1 - progress);
                            
                            // The large rotation value ensures fast spin, compensating for low/variable frame rates
                            b.rotation.y += (Math.PI * 2) * (deltaTime / duration); 
                            b.rotation.z += (Math.PI / 2) * (deltaTime / duration);
                        });
                        requestAnimationFrame(animateClear);
                    } else {
                        // Animation complete, finalize cleanup
                        
                        // Remove animated blocks visually
                        gameBoard.children = gameBoard.children.filter(block => {
                            if (block === currentPiece) return true; 
                            const blockY = Math.round(BOARD_HEIGHT / 2 - 0.5 - (block.position.y / BLOCK_SIZE));
                            return !rowsToClear.includes(blockY); 
                        });
                        
                        // Shift Grid Data
                        for (const y of rowsToClear.sort((a, b) => a - b)) { 
                            grid.splice(y, 1);
                            grid.unshift(Array(BOARD_WIDTH).fill(0));
                        }
                        
                        // Shift Visual Blocks down
                        gameBoard.children.forEach(block => {
                            if (block === currentPiece) return; 
                            const blockY = Math.round(BOARD_HEIGHT / 2 - 0.5 - (block.position.y / BLOCK_SIZE));
                            let shift = 0;
                            for (const clearedY of rowsToClear) {
                                if (blockY < clearedY) shift++;
                            }
                            if (shift > 0) block.position.y -= shift * BLOCK_SIZE;
                        });
                        
                        updateScore(linesCleared);
                        
                        // Resume Game
                        gameLoopInterval = setInterval(gameTick, currentDropSpeed);
                    }
                }
                // Start animation loop using precise time measurement
                lastTimestamp = performance.now();
                requestAnimationFrame(animateClear);
            }
        }

        function movePiece(direction) {
            if (!currentPiece) return;
            if (isValidMove(currentPiece, { x: direction })) {
                currentPiece.userData.gridPos.x += direction;
                updatePiecePosition(currentPiece);
                triggerHaptic(5); 
                // Sound removed for normal moves
            }
        }
        
        function updatePiecePosition(piece) {
            const ud = piece.userData;
            piece.position.set(
                (ud.gridPos.x - BOARD_WIDTH / 2 + 0.5) * BLOCK_SIZE,
                (BOARD_HEIGHT / 2 - 0.5 - ud.gridPos.y) * BLOCK_SIZE,
                0 
            );
        }

        function spawnPiece() {
            // FIXED: CRITICAL CHECK TO PREVENT STUCK PIECES ON GAME OVER
            if (gameState !== GAME_STATE.PLAYING) return;

            const typeIndex = Math.floor(Math.random() * SHAPES.length);
            const rotationIndex = 0; 
            const shape = SHAPES[typeIndex][rotationIndex];
            
            // New piece spawns at grid y=0. Check if this row is already blocked.
            if (shape.length > 0) {
                const spawnRow = 0; 
                const shapeWidth = shape[0].length;
                const spawnX = Math.floor((BOARD_WIDTH - shapeWidth) / 2);

                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x]) {
                            const boardX = spawnX + x;
                            const boardY = spawnRow + y;
                            if (boardY >= 0 && grid[boardY][boardX]) {
                                // Collision detected at spawn point - Game Over!
                                gameOver();
                                return;
                            }
                        }
                    }
                }
            }


            const color = COLORS[typeIndex + 1];
            
            const piece = new THREE.Group();
            piece.userData = { shape: shape, typeIndex: typeIndex, rotationIndex: rotationIndex, gridPos: { x: Math.floor((BOARD_WIDTH - shape[0].length) / 2), y: 0 } };
            
            const blockGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE * 0.8);
            const blockMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5, metalness: 0.1 });
            const bevelGeo = new THREE.EdgesGeometry(blockGeo);
            const bevelMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const block = new THREE.Mesh(blockGeo, blockMat);
                        const bevel = new THREE.LineSegments(bevelGeo, bevelMat);
                        block.add(bevel);
                        block.position.set(x * BLOCK_SIZE, -y * BLOCK_SIZE, 0);
                        piece.add(block);
                    }
                }
            }
            updatePiecePosition(piece);
            gameBoard.add(piece);
            currentPiece = piece;
        }
        
        function rotatePiece() {
            if (!currentPiece) return;
            const ud = currentPiece.userData;
            const newRotationIndex = (ud.rotationIndex + 1) % SHAPES[ud.typeIndex].length;
            const newShape = SHAPES[ud.typeIndex][newRotationIndex];
            const kicks = [0, 1, -1, 2, -2]; 
            for (const kick of kicks) {
                const testPos = { x: ud.gridPos.x + kick, y: ud.gridPos.y };
                if (isValidMove(currentPiece, { shape: newShape, pos: testPos })) {
                    ud.rotationIndex = newRotationIndex;
                    ud.shape = newShape;
                    ud.gridPos.x = testPos.x; 
                    while (currentPiece.children.length) currentPiece.remove(currentPiece.children[0]);
                    
                    const color = COLORS[ud.typeIndex + 1];
                    const blockGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE * 0.8);
                    const blockMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5, metalness: 0.1 });
                    const bevelGeo = new THREE.EdgesGeometry(blockGeo);
                    const bevelMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            
                    for (let y = 0; y < newShape.length; y++) {
                        for (let x = 0; x < newShape[y].length; x++) {
                            if (newShape[y][x]) {
                                const block = new THREE.Mesh(blockGeo, blockMat);
                                const bevel = new THREE.LineSegments(bevelGeo, bevelMat);
                                block.add(bevel);
                                block.position.set(x * BLOCK_SIZE, -y * BLOCK_SIZE, 0);
                                currentPiece.add(block);
                            }
                        }
                    }
                    updatePiecePosition(currentPiece);
                    triggerHaptic(5); 
                    // Changed: Now uses the low latency synth function directly here
                    playRotateSound();
                    return; 
                }
            }
        }
        
        function hardDrop() {
            if (!currentPiece) return;
            while (isValidMove(currentPiece, { y: 1 })) {
                currentPiece.userData.gridPos.y += 1;
            }
            updatePiecePosition(currentPiece);
            lockPiece();
            spawnPiece();
            clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameTick, currentDropSpeed); 
            triggerHaptic(20); 
        }

        function isValidMove(piece, delta) {
            const ud = piece.userData;
            const shape = delta.shape || ud.shape;
            const newGridX = (delta.pos ? delta.pos.x : ud.gridPos.x) + (delta.x || 0);
            const newGridY = (delta.pos ? delta.pos.y : ud.gridPos.y) + (delta.y || 0);

            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = newGridX + x;
                        const boardY = newGridY + y; 
                        if (boardX < 0 || boardX >= BOARD_WIDTH) return false;
                        if (boardY >= BOARD_HEIGHT) return false;
                        if (boardY >= 0 && grid[boardY][boardX]) return false;
                    }
                }
            }
            return true;
        }

        function lockPiece() {
            if (!currentPiece) return;
            const ud = currentPiece.userData;
            const shape = ud.shape;
            const gridX = ud.gridPos.x;
            const gridY = ud.gridPos.y; 
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const boardX = gridX + x;
                        const boardY = gridY + y;
                        if (boardY < 0 || boardY >= BOARD_HEIGHT) continue; 
                        grid[boardY][boardX] = ud.typeIndex + 1;
                        
                        const color = COLORS[ud.typeIndex + 1];
                        const blockGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE * 0.8);
                        const blockMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5, metalness: 0.1 });
                        const bevelGeo = new THREE.EdgesGeometry(blockGeo);
                        const bevelMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                        const newBlock = new THREE.Mesh(blockGeo, blockMat);
                        const newBevel = new THREE.LineSegments(bevelGeo, bevelMat);
                        newBlock.add(newBevel);
                        
                        newBlock.position.set(
                            (boardX - BOARD_WIDTH / 2 + 0.5) * BLOCK_SIZE,
                            (BOARD_HEIGHT / 2 - 0.5 - boardY) * BLOCK_SIZE,
                            0
                        );
                        gameBoard.add(newBlock);
                    }
                }
            }
            gameBoard.remove(currentPiece);
            currentPiece = null;
            checkLineClears();
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * bitsPerSample / 8;
            const blockAlign = numChannels * bitsPerSample / 8;
            const dataSize = pcmData.length * 2; 
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); 
            view.setUint16(20, 1, true); 
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            for (let i = 0; i < pcmData.length; i++) view.setInt16(44 + i * 2, pcmData[i], true);
            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
        }
    </script></body>
</html>